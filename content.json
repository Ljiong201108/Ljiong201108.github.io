{"posts":[{"title":"CF1324F Maximum White Subtree 题解","text":"传送门: F. Maximum White Subtree 给予你一颗无根树，树上的节点被染成黑色或者白色，求对于某一个节点，在任意包含这个节点的子树中，问白色的节点数量最多能比黑色节点多多少个？ 例： 黑色节点为加粗边框的节点 对于节点4，答案为2，选的子树为$(3,4)$ 对于无根树，应该先想的转换成有根树，不妨设根节点为1 对于根节点，其答案只与他的子节点有关，我们定义$f_u$：在以节点1为根节点的条件下，在以节点$u$为根的子树中，选择一个包含节点$u$的树，白色节点能比黑色节点多的最大数量。用样例中的节点3举例，这里的子树为$(3,4,7,5,9)$，所以$f_3$为2，选的树为$(3,4)$ 至此，基本的DP思路就出来了，对于一个节点$u$，便利一下$u$的子节点$v$，若是在以$v$为根的子树中，通过选择白色节点能比黑色节点多，即$f_v$非负，那我们就可以（应该）选择加上$v$这个节点以及$v$选中的子节点以及$v$选中的子节点选中的子节点……（禁止套娃），但是我们只关心数量，不关心选中了哪些节点。综上就有了下面这个DP方程： 对于某个节点$u$ f_u=colour_u+\\sum_{\\text v \\in \\text{Subtree}(u)}max(f_v, 0)其中$colour_u$代表节点$u$对于答案的贡献值，若$u$为白色节点，则$colour_u$为1，否则为-1 至此我们就得到了一个朴素的解法：让每个点都做一次根节点，跑一次上述所说的DP，复杂度为$O(n^2)$，可惜是过不了的，我们还得找新的解法 通过观察我们可以发现，对于非根节点，整棵树除去以这个节点为根的子树的余下部分可能对答案也有影响，例如样例中的节点9。我们定义$g_u$：在以节点1为根节点的条件下，在整棵树除去以节点$u$为根的子树中（但是保留节点$u$），选择一个包含节点$u$​的树，白色节点能比黑色节点多的最大数量。用样例中的节点3举例，这里的树为$(3,1, 2, 6, 8)$，所以$g_3$为1，选的树为$(3)$或者$(3, 1, 2)$ 然后就是思考如何能够推出$gu$，通过观察我们可以发现，$g{fa(u)}$和$g_u$其实有公共部分，如下图： 当$u=5$时，红色区域表示$gu$，蓝色区域表示$g{fa(u)}$，两者差了一个$colour_u$和$fa(u)$的若干个子节点对于答案的影响，所以我们可以推出关于$g$的DP方程： 对于某个节点$u$ g_u=colour_u+max(g_{fa(u)}+\\sum_{\\text v \\in \\text{Subtree(fa(u)) and v} \\neq \\text{u}} max(f_v, 0), 0)但是要递推这个DP的复杂度为$O(n^2)$，我们必须优化一下。可以注意到，在这个方程中后面的一部分和$f$的DP方程类似，考虑从这块入手： f_{fa(u)}-colour_{fa(u)}=\\sum_{\\text v \\in \\text{Subtree(fa(u))}} max(f_v, 0)=\\sum_{\\text v \\in \\text{Subtree(fa(u)) and v} \\neq \\text{u}} max(f_v, 0)+max(f_u, 0)把右边的$max(f_u, 0)$移到左边去： \\sum_{\\text v \\in \\text{Subtree(fa(u)) and v} \\neq \\text{u}} max(f_v, 0)=f_{fa(u)}-colour_{fa(u)}-max(f_u, 0)代回$g$的DP方程： g_u=colour_u+max(g_{fa(u)}+f_{fa(u)}-colour_{fa(u)}-max(f_u, 0), 0)因为$f$在推$g$的时候应该已经计算完成了，所以只需便利一遍图便可推出$g$，复杂度$O(n)$ 而计算答案$ans_u$的时候本应该将$f$和$g$相加，但是$colour_u$会被重复计算一次，所以要减掉： ans_u=f_u+max(g_u-colour_u, 0)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define pll pair&lt;ll, ll&gt;using namespace std;typedef long long ll;int n;void dfsf(int u, int fa, vector&lt;vector&lt;int&gt;&gt; &amp;G, vector&lt;int&gt; &amp;f, vector&lt;int&gt; &amp;colour){ int sum=0; for(int i=0;i&lt;G[u].size();i++){ int v=G[u][i]; if(v==fa) continue; dfsf(v, u, G, f, colour); //注意这里要在求和之前先把子节点算完 sum+=max(f[v], 0); } f[u]=colour[u]+sum;}void dfsg(int u, int fa, vector&lt;vector&lt;int&gt;&gt; &amp;G, vector&lt;int&gt; &amp;f, vector&lt;int&gt; &amp;g, vector&lt;int&gt; &amp;colour, vector&lt;int&gt; &amp;ans){ g[u]=colour[u]+max(0, g[fa]+f[fa]-max(0, f[u])-colour[fa]); ans[u]=f[u]+max(0, g[u]-colour[u]); for(int i=0;i&lt;G[u].size();i++){ int v=G[u][i]; if(v==fa) continue; dfsg(v, u, G, f, g, colour, ans); }}void Main(int kase){ cin&gt;&gt;n; vector&lt;int&gt; colour(n+1), f(n+1), g(n+1), ans(n+1); vector&lt;vector&lt;int&gt;&gt; G(n+1, vector&lt;int&gt;()); for(int i=1;i&lt;=n;i++){ cin&gt;&gt;colour[i]; if(colour[i]==0) colour[i]=-1; } int u, v; for(int i=1;i&lt;n;i++){ cin&gt;&gt;u&gt;&gt;v; G[u].push_back(v); G[v].push_back(u); } dfsf(1, 0, G, f, colour); dfsg(1, 0, G, f, g, colour, ans); for(int i=1;i&lt;=n;i++){ cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}int main(){ #ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif ios_base::sync_with_stdio(0); cin.tie(0); Main(1); return 0;}","link":"/2021/09/27/CF1324F-Maximum-White-Subtree%E9%A2%98%E8%A7%A3-%E6%A0%91%E5%BD%A2DP%E4%B9%8B%E6%8D%A2%E6%A0%B9DP/"},{"title":"CF1574D The Strongest Build 题解","text":"传送门：The Strongest Build 你有$n$个物品槽，每个物品槽可以存放一个物品。现在对于每个物品槽，有若干个物品可以选择，但是有$m$个物品组合是被禁用的。每个物品有一个价值，求没被禁用的物品组合的最大价值之和是哪个物品组合。 物品组合：当这$n$个物品槽都选定一个物品后，这$n$个物品构成一个物品组合。 通过观察可以知道，如果所有物品槽都选择那个最大价值的物品，则这个物品组合的价值之和最大，但是这个物品组合可能会被禁用掉，所以我们要从最大的组合推次大的组合、次次大的组合等等 这个推理的过程其实也不难想到：对于最大的组合来说，某一个物品槽取第二大的物品，一共$n$种可能，其中必定存在次大的组合。哪怎么求次次大的组合呢？对于次大的组合来说，某一个物品槽取再小一点的物品， 一共$n$种可能的情况，再加上选次大的时候剩下的$n-1$种可能情况，次次大的组合一定在这$2n-1$种情况中，以此类推。 实现方式我选择优先队列来排序可能的情况，set来查找某个组合的禁用情况和是否被查过了。（STL yyds~） AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;#define pll pair&lt;ll, ll&gt;using namespace std;typedef long long ll;int n, m;vector&lt;vector&lt;int&gt;&gt; A;struct build{ int value; vector&lt;int&gt; content; build(vector&lt;int&gt; vec): content(vec){ value=0; for(int i=0;i&lt;content.size();i++){ value+=A[i+1][content[i]]; } } void inc(int x){ value-=A[x+1][content[x]]; content[x]++; value+=A[x+1][content[x]]; } void dec(int x){ value-=A[x+1][content[x]]; content[x]--; value+=A[x+1][content[x]]; } void printans(){ for(int i=0;i&lt;content.size();i++){ cout&lt;&lt;content[i]&lt;&lt;&quot; &quot;; } } bool operator&lt;(const build &amp;other) const{ if(value!=other.value) return value&lt;other.value; else{ for(int i=0;i&lt;content.size();i++){ if(content[i]!=other.content[i]) return content[i]&lt;other.content[i]; } return 0; } }};void Main(int kase){ cin&gt;&gt;n; A.resize(n+1); vector&lt;int&gt; vec; for(int i=1, sz;i&lt;=n;i++){ cin&gt;&gt;sz; vec.push_back(sz); A[i].resize(sz+1); for(int j=1;j&lt;=sz;j++){ cin&gt;&gt;A[i][j]; } } priority_queue&lt;build&gt; Q; set&lt;build&gt; vis; build first(vec); Q.push(first); vis.insert(first); cin&gt;&gt;m; set&lt;build&gt; bans; for(int i=1;i&lt;=m;i++){ for(int j=0;j&lt;n;j++){ cin&gt;&gt;vec[j]; } build ban(vec); bans.insert(ban); } while(!Q.empty()){ build cur=Q.top(); Q.pop(); build next(cur.content); if(bans.find(cur)==bans.end()){ cur.printans(); return; } for(int i=0;i&lt;cur.content.size();i++){ if(cur.content[i]==1) continue; next.dec(i); if(vis.find(next)==vis.end()){ Q.push(next); vis.insert(next); } next.inc(i); } }}int main(){ #ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif ios_base::sync_with_stdio(0); cin.tie(0); Main(1); return 0;}","link":"/2021/09/28/CF1574D-The-Strongest-Build-%E9%A2%98%E8%A7%A3-%E6%80%9D%E7%BB%B4-STL/"},{"title":"CF1622D Shuffle 题解","text":"传送门：Shuffle 给定一个二进制字符串，你可以对这个字符串进行最多一次如下的操作： 从$s$中选择一个正好有$k$个1字符的子串，然后你可以随意的打乱它。 计算可以从$s$经过这样一次操作之后能得到的不同的字符串的数量之和 从这道题的数据来看，$O(n^2)$的复杂度是能过的，一开始想过遍历所有的符合要求的字串，排列组合之后统计答案，但是这样的话重复的数量不是很好去除。 我们可以发现，经过一次操作之后，原字符串仅会被改变一个连续的部分，这个部分应该是一个合法的字串的一部分（因为可以只改变这个子串的一部分）。 我们就可以枚举这个连续的部分的两端，我们规定这两个端点是必须在一次操作之后被改变的，不然的话会有好几个：以010100举例，中间的1010是被选出来改过的，原来的字符串就必须是10xx10，这样就能够更简单的计算了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;using namespace std;typedef long long ll;ll fastPower(ll base, ll power, ll mod) { ll result = 1; while (power &gt; 0) { if (power &amp; 1) { result = result * base % mod; } power &gt;&gt;= 1; base = (base * base) % mod; } return result;}const ll MOD=998244353;//阶乘逆元ll fac[200010]; //阶乘ll inv[200010]; //逆元 void getfac(){ fac[0] = inv[0] = 1; for (int i = 1 ; i &lt;= 200000 ; i++) { fac[i] = fac[i-1] * i % MOD; inv[i] = fastPower(fac[i], MOD-2, MOD); //表示i的阶乘的逆元 }}//组合数inline ll getC(ll n,ll m)//C(n,m) = n!/((n-m)!*m!) % MOD{ return fac[n] * inv[n-m] % MOD * inv[m] % MOD;}//当 n，m 过大时，可以用Lucas定理降数据inline ll Lucas(ll n,ll m){ if(n &lt; MOD &amp;&amp; m &lt; MOD) return getC(n, m); return Lucas(n/MOD, m/MOD) * getC(n%MOD, m%MOD)%MOD;}//排列数inline ll getA(ll n,ll m) //A(n,m) = n!/(n-m)! % MOD{ return n * inv[n-m] % MOD;}ll n, k, ans=1;void Main(int kase){ cin&gt;&gt;n&gt;&gt;k; char c; vector&lt;ll&gt; A(n+1), S(n+1); for(ll i=1;i&lt;=n;i++){ cin&gt;&gt;c; A[i]=c-'0'; S[i]=S[i-1]+A[i]; // 前缀和 } if(S[n]&lt;k) { //若是所有的1加起来都不够k的话,直接返回 cout&lt;&lt;1&lt;&lt;endl; return; } for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ int cnt=j-i+1; int cnt1=S[j]-S[i-1]; if(cnt1&gt;k) continue; //i与j之间的1的数量小于等于k个,确保i到j是一个合法的子串的一部分 if(A[i]==0) cnt1--; if(A[j]==0) cnt1--; cnt-=2; if(cnt1&gt;=0 &amp;&amp; cnt&gt;=0 &amp;&amp; cnt1&lt;=cnt) ans=(ans+getC(cnt, cnt1))%MOD; } } cout&lt;&lt;ans&lt;&lt;endl;}int main(){ #ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif ios_base::sync_with_stdio(0); cin.tie(0); getfac(); Main(1); return 0;}","link":"/2022/01/07/CF1622D-Shuffle-%E9%A2%98%E8%A7%A3-%E6%80%9D%E7%BB%B4/"},{"title":"CF1728D Letter Picking 题解","text":"传送门：Letter Picking 给定一个长度是$n(n \\leq 2000 \\text{并且} n \\text{是偶数})$的字符串$S$，Alice和Bob轮流从这个字符串的头或者尾取一个字符加在自己的字符串的头部，Alice先手，最后谁的字符串字典序小，谁就获胜。 那么谁能获胜呢？ 这题其实是有结论可以推的，但是需要推蛮久的，我看大牛都是选择使用$dp$硬刚的，其实我也蛮喜欢硬刚的，可以少掉点头发 结论在洛谷题解的第一篇 下面是$dp$的解法 设$dp(l,r)$是区间$l$到$r$的结果。$-1$表示Alice输，$0$表示平局，$1$表示Alice胜。 假设Alice现在取的是$Sl$，那么Bob可以选择取$S{l+1}$或者$S_r$，对应的前置结果就是$dp(l+2, r)$和$dp(l+1, r-1)$。 假设Alice现在取的是$Sr$，那么Bob可以选择取$S{l}$或者$S_{r-1}$，对应的前置结果就是$dp(l+1, r+1)$和$dp(l, r-2)$。 分别考虑两种情况，如果两种前置结果都是Alice赢，那Alice必赢。若是出现平局，Bob肯定会选择平局而不是让Alice赢，这种情况下，就要比较当前区间内Alice和Bob各自选择的字母了。如果不是这两种情况，那Alice就输了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253string s;int n;int normalize(int x){ return x&gt;0 ? 1 : x==0 ? 0 : -1;}int f(int l, int r, v2(int) &amp;dp){ if(l&gt;r) return 0; if(dp[l][r]!=INT_MAX) return dp[l][r]; int ans1=f(l, r-2, dp); int ans2=f(l+1, r-1, dp); int ans3=f(l+2, r, dp); int ans=INT_MIN; if(ans2==1 &amp;&amp; ans3==1) ans=max(ans, 1); if(ans2==0 &amp;&amp; ans3==1) ans=max(ans, normalize(s[r]-s[l])); if(ans2==1 &amp;&amp; ans3==0) ans=max(ans, normalize(s[l+1]-s[l])); if(ans2==0 &amp;&amp; ans3==0){ int tmpans; if(normalize(s[r]-s[l])==1 &amp;&amp; normalize(s[l+1]-s[l])==1) tmpans=1; else if(normalize(s[r]-s[l])==0 &amp;&amp; normalize(s[l+1]-s[l])==1) tmpans=0; else if(normalize(s[r]-s[l])==1 &amp;&amp; normalize(s[l+1]-s[l])==0) tmpans=0; else if(normalize(s[r]-s[l])==0 &amp;&amp; normalize(s[l+1]-s[l])==0) tmpans=0; else tmpans=-1; ans=max(ans, tmpans); } if(ans2==-1 || ans3==-1) ans=max(ans, -1); if(ans1==1 &amp;&amp; ans2==1) ans=max(ans, 1); if(ans1==0 &amp;&amp; ans2==1) ans=max(ans, normalize(s[r-1]-s[r])); if(ans1==1 &amp;&amp; ans2==0) ans=max(ans, normalize(s[l]-s[r])); if(ans1==0 &amp;&amp; ans2==0){ int tmpans; if(normalize(s[r-1]-s[r])==1 &amp;&amp; normalize(s[l]-s[r])==1) tmpans=1; else if(normalize(s[r-1]-s[r])==0 &amp;&amp; normalize(s[l]-s[r])==1) tmpans=0; else if(normalize(s[r-1]-s[r])==1 &amp;&amp; normalize(s[l]-s[r])==0) tmpans=0; else if(normalize(s[r-1]-s[r])==0 &amp;&amp; normalize(s[l]-s[r])==0) tmpans=0; else tmpans=-1; ans=max(ans, tmpans); } if(ans1==-1 || ans2==-1) ans=max(ans, -1); return dp[l][r]=ans;}void Main(int kase){ cin&gt;&gt;s; n=s.size(); v2(int) dp(n+1, v1(int)(n+1, INT_MAX)); cout&lt;&lt;(f(0, n-1, dp)==1 ? &quot;Alice&quot; : f(0, n-1, dp)==0 ? &quot;Draw&quot; : &quot;Bob&quot;)&lt;&lt;endl;}","link":"/2022/12/07/CF1728D-Letter-Picking-%E9%A2%98%E8%A7%A3/"},{"title":"CF1729E Guess the Cycle Size 题解","text":"传送门：Guess the Cycle Size 给你一个无向环形图，图上有$n(3 \\leq n \\leq 10^{18})$个节点，一次能询问两个点之间的距离，但是返回的是两个距离中的任意一个，在只有$50$次的询问下，问环的长度是多少。 水题！ 这种概率题一般就这样了吧😅。 问两个相同的点两次，如果返回的值是不同的，直接得出结果。 若是相同的，就再问一遍。这样$50$次下来，$50$次全给出相同的值但是两条边长度不同的概率是$2^{-25}$，一般不会寄，除非是真的脸黑。 这题还要注意的一个点就是，评测机对相同的有序点对会返回相同的值，所以问完一次之后要换两个点问！ 1234567891011121314151617181920212223242526272829ll ask(ll a, ll b){ ll ret; std::cout&lt;&lt;&quot;? &quot;&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;std::endl; std::cout.flush(); std::cin&gt;&gt;ret; return ret;}void succ(ll a){ std::cout&lt;&lt;&quot;! &quot;&lt;&lt;a&lt;&lt;std::endl; std::cout.flush();}void Main(int kase){ for(ll i=2;i&lt;=26;i++){ ll ans1=ask(1, i); ll ans2=ask(i, 1); if(ans1==-1){ succ(i-1); return; } if(ans1!=ans2){ succ(ans1+ans2); return; } }}","link":"/2022/12/07/CF1729E-Guess-the-Cycle-Size-%E9%A2%98%E8%A7%A3/"},{"title":"CF1732C Sheikh (easy &amp; hard) 题解","text":"传送门：Sheikh 给定一串长度为$n(1 \\leq n \\leq 10^5)$的数列$a1, a_2, \\ldots, a_n\\left(0 \\leq a_i \\leq 10^9\\right)$，定义$f(l, r)=\\operatorname{sum}(l, r)-\\operatorname{xor}(l, r)$，其中$\\operatorname{sum}(l, r)=a_l+a{l+1}+\\ldots+ar$，$\\operatorname{xor}(l, r)=a_l \\oplus a{l+1} \\oplus \\ldots \\oplus a_r$，一共有$q$次询问，每次询问会给定一个区间，询问这个区间内满足$f$最大的最短的子段。 一眼顶针，这个$f$算的其实就是区间内的加法运算的进位之和，因为$\\oplus$其实就是不进位的加法。那既然是进位的，$f$必定是非负的，那最短的字段就是掐头去尾没进位的部分就好了。考虑进位，如果某一个二进制位上有两个$1$，那这一位必定进位，但是此时我们还不能用鸽巢原理，因为数列中可能是有零存在的，我们先要去掉所有的$0$，然后在新的数列中，由鸽巢原理就可以知道，最多$30$个二进制位，则数列头尾最多$30$个数是不进位的，暴力枚举就好了。 123456789101112131415161718192021222324252627282930313233343536373839ll an, q;ll f(ll l, ll r, vector&lt;ll&gt; &amp;S, vector&lt;ll&gt; &amp;X){ return (S[r]-S[l-1])-(X[r]^X[l-1]);}void Main(int kase){ cin&gt;&gt;an&gt;&gt;q; ll bn; vector&lt;ll&gt; A(an+1), B(1), S(1), X(1); for(ll i=1;i&lt;=an;i++){ cin&gt;&gt;A[i]; if(A[i]!=0) B.push_back(i), S.push_back((*prev(S.end()))+A[i]), X.push_back((*prev(X.end()))^A[i]); } for(ll i=1;i&lt;=q;i++){ ll l, r; cin&gt;&gt;l&gt;&gt;r; // 找出新数列中原数列中数字的位置 ll tl=lower_bound(B.begin()+1, B.end(), l)-B.begin(); ll tr=upper_bound(B.begin()+1, B.end(), r)-B.begin()-1; if(B.size()==1 || tl&gt;tr){ cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;endl; continue; } ll ansl=tl, ansr=tr; for(ll i=tl;i&lt;=tl+30;i++){ for(ll j=tr-30;j&lt;=tr;j++){ if(!(tl&lt;=i &amp;&amp; i&lt;=tr) || !(tl&lt;=j &amp;&amp; j&lt;=tr)) continue; if(i&lt;=j &amp;&amp; f(i, j, S, X)==f(tl, tr, S, X) &amp;&amp; B[j]-B[i]&lt;B[ansr]-B[ansl]) ansl=i, ansr=j; } } cout&lt;&lt;B[ansl]&lt;&lt;&quot; &quot;&lt;&lt;B[ansr]&lt;&lt;endl; }}","link":"/2022/12/07/CF1732C-Sheikh-easy-hard-%E9%A2%98%E8%A7%A3/"},{"title":"CF1734D Slime Escape 题解","text":"传送门：Slime Escape 一条直线上有$n(3 \\leq n \\leq 200000)$个史莱姆，你能控制第$k(1 \\leq k \\leq n)$个，第$i$个史莱姆的生命值是$a_i$。 现在你可以控制这个史莱姆向左或者向右“吞噬”别的史莱姆，你每“吞噬”一个史莱姆$i$，你控制的史莱姆的生命值会增加$a_i$，但是有的史莱姆的生命值是负的，一旦你控制的史莱姆的生命值也变成负的话，你就输掉了游戏。 通关的目标是走到最左边或者走到最右边，问你有没有可行的解。 第一眼看到这道题本来以为是道水题（？），不断的吞噬最相邻的两个史莱姆，直到出去，但是 wrong answer test case 2了 1800的题哪有这么水的 正解是以你操纵的那个史莱姆为中心，不断地往外划分区块。一共有两种不同的区块类型： 区块里的数字之和是非负数的区块 除了第一种区块，两边可能会剩下一些和不是非负数但是吞掉这个区块就能通关的 每个区块要记一个最低吞噬的生命值，这也很好理解。对于第一个区块，如果能够吞噬，那肯定选择吞掉，这样可以获得更多的生命值来通关；第二种如果能吞掉就直接通关了。 这是第三个样例的区块划分： 预处理好之后能吞就吞，如果没有能吞的之后还是没有通关，则不可能通关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ll n, k;void Main(int kase){ cin&gt;&gt;n&gt;&gt;k; vector&lt;ll&gt; A(n+1); for(ll i=1;i&lt;=n;i++) cin&gt;&gt;A[i]; queue&lt;pll&gt; Q1, Q2; ll sum=0, mn=LLONG_MAX; for(ll i=k-1;i&gt;=1;i--){ sum+=A[i]; mn=min(mn, sum); if(sum&gt;=0){ Q1.push(make_pair(sum, -mn)); sum=0; mn=LLONG_MAX; } } Q1.push(make_pair(sum, -mn)); sum=0; mn=LLONG_MAX; for(ll i=k+1;i&lt;=n;i++){ sum+=A[i]; mn=min(mn, sum); if(sum&gt;=0){ Q2.push(make_pair(sum, -mn)); sum=0; mn=LLONG_MAX; } } Q2.push(make_pair(sum, -mn)); sum=0; mn=LLONG_MAX; ll cur=A[k]; while(!Q1.empty() &amp;&amp; !Q2.empty()){ if(cur&lt;Q1.front().second &amp;&amp; cur&lt;Q2.front().second){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return; } while(!Q1.empty() &amp;&amp; cur&gt;=Q1.front().second) cur+=Q1.front().first, Q1.pop(); while(!Q2.empty() &amp;&amp; cur&gt;=Q2.front().second) cur+=Q2.front().first, Q2.pop(); } cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;}","link":"/2022/12/07/CF1734D-Slime-Escape-%E9%A2%98%E8%A7%A3/"},{"title":"CF1758D Range &#x3D; √Sum 题解","text":"传送门：Range = √Sum 给定一个正整数$n(1 \\leq n \\leq 3 \\cdot 10^5)$，找出一串$n$个不同的数的数列$a_1, a_2, … , a_n(1 \\leq a_i \\leq 10^9)$，满足以下式子： \\max \\left(a_1, a_2, \\ldots, a_n\\right)-\\min \\left(a_1, a_2, \\ldots, a_n\\right)=\\sqrt{a_1+a_2+\\cdots+a_n} 如果$n$是偶数，我们可以直接构造：$n-\\frac{n}{2}, n-\\frac{n}{2}+1, …, n-1, n+1, …, n+\\frac{n}{2}-1, n+\\frac{n}{2}$，这样$\\max \\left(a_1, a_2, \\ldots, a_n\\right)-\\min \\left(a_1, a_2, \\ldots, a_n\\right)$就是$n+\\frac{n}{2}-(n-\\frac{n}{2})=n$，$\\sqrt{a_1+a_2+\\cdots+a_n}=\\sqrt{n^2}=n$，满足题意 如果$n$是奇数，我们就不能这么构造了，我的做法是微调$n-1$情况下的那些数字，再加上$n$本身，正好就是$n$个数字，让右边根号下能是一个完全平方数，这个数是$(n+1)^2$。 $(n+1)^2 - n^2 = 2n+1$，也就是说我们要往这些数字里面加上$2n-1$。 首先，先给最后一个数加上$2$，这一步之后$\\max \\left(a_1, a_2, \\ldots, a_n\\right)-\\min \\left(a_1, a_2, \\ldots, a_n\\right)$就变成$n+1$了，并且后面的操作不会再改变这个值了。 再让每个数加上一。此时还剩$n-1$，我让除了首尾的$n-2$个数都加上一，还剩最后一个，加在倒数第二个数上面就好了。 用一个例子来说明：$n=5$的情况下： $(3,4,5,6,7) \\rightarrow (3,4,5,6,9) \\rightarrow (4,5,6,7,10) \\rightarrow (4,6,7,8,10) \\rightarrow (4,6,7,9,10)$ 1234567891011121314151617int n;void Main(int kase){ cin&gt;&gt;n; if(n%2==0){ for(int i=n-n/2;i&lt;n;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;; for(int i=n+1;i&lt;=n+n/2;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; }else{ cout&lt;&lt;n-n/2+1&lt;&lt;&quot; &quot;; int i=n-n/2+3; for(int cnt=1;cnt&lt;=n-3;i++, cnt++) cout&lt;&lt;i&lt;&lt;&quot; &quot;; cout&lt;&lt;i+1&lt;&lt;&quot; &quot;; cout&lt;&lt;n+n/2+3&lt;&lt;endl; }}","link":"/2022/12/05/CF1758D-Range-%E2%88%9ASum-%E9%A2%98%E8%A7%A3/"},{"title":"CF1759F All Possible Digits 题解","text":"传送门：All Possible Digits 给定一个数字$n(1 \\leq n \\leq 100)$，进制$p(2 \\leq p \\leq 10^9)$，并且给出这个数在$p$进制下的表示。现在有一个操作，即给这个数加上1，问要操作几次才能让$p$进制下的所有数位都出现一次？ 观察可知，这个操作次数的上限是$p$，考虑到一直往上加会出现进位的情况，我们先分类讨论： 如果没出现进位，这种情况下，小于最低位的数字应当都出现过了一次 反之就是必须得进位一次才能让所有数位都出现一次 观察$n$的取值范围，这个值是相当小的，我们可以从两种情况的最大值开始往下枚举第一个包含没出现过数位的数，枚举的次数不超过100次，最后再统计答案就好了 1234567891011121314151617181920212223242526int n, p;void Main(int kase){ cin&gt;&gt;n&gt;&gt;p; vector&lt;int&gt; A(n+1); for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i]; int cnt=0; map&lt;int, int&gt; M; for(int i=1;i&lt;n;i++) {if(A[i]&lt;A[n]) cnt+=M[A[i]]!=1; M[A[i]]=1;} if(cnt==A[n]){ // 从最大值开始往下查 int i=p-1; for(;i&gt;A[n];i--) if(!M[i]) break; cout&lt;&lt;i-A[n]&lt;&lt;endl; }else{ int i=n-1; // 进位可能导致出现新的数位，先把新出现的统计上去 for(;i&gt;=0;i--) if(A[i]!=p-1){A[i]++; break;} M[A[i]]=1; // 从最大值开始往下查 i=A[n]-1; for(;i&gt;=1;i--) if(!M[i]) break; cout&lt;&lt;p-1-A[n]+1+i&lt;&lt;endl; }}","link":"/2022/12/05/CF1759F-All-Possible-Digits-%E9%A2%98%E8%A7%A3/"},{"title":"Codeforces Round 862 (1805)","text":"比赛链接 .post-summary { display: none; } A. We Need the Zero按位考虑结果，$x$中的每一位对结果都会造成$n$次影响。 12345678910111213141516171819202122232425262728293031323334int n;void Main(int kase) { cin &gt;&gt; n; v1(int) A(n + 1); for (int i = 1;i &lt;= n;i++) cin &gt;&gt; A[i]; v1(int) digs(8); for (int j = 1;j &lt;= n;j++) { for (int i = 0;i &lt; 8;i++) { digs[i] += A[j] % 2; A[j] /= 2; } } v1(int) ans(8); for (int i = 0;i &lt; 8;i++) { if (digs[i] % 2 == 0) ans[i] = 0; else if ((digs[i] + n) % 2 == 0) ans[i] = 1; else { cout &lt;&lt; -1 &lt;&lt; endl; return; } } int ret = 0, base = 1; for (int i = 0;i &lt; 8;i++) { ret += ans[i] * base; base *= 2; } cout &lt;&lt; ret &lt;&lt; endl;} B. The String Has a Target考虑第二位之后有没有比第一位还要小或者等于第一位的字符，有的话就移到第一个。 123456789101112131415161718192021222324252627int n;string input;void Main(int kase){ cin&gt;&gt;n&gt;&gt;input; int pos=0; char c=input[0]; for(int i=1;i&lt;input.size();i++){ if(input[i]&lt;=c){ pos=i; c=input[i]; } } if(pos==0){ cout&lt;&lt;input&lt;&lt;endl; return; } cout&lt;&lt;c; for(int i=0;i&lt;input.length();i++){ if(i==pos) continue; cout&lt;&lt;input[i]; } cout&lt;&lt;endl;} C. Place for a Selfie数学题。考虑对于抛物线$y=ax^2+bx+c$什么情况下会和过原点的直线$y=kx$没有交点。 考虑联立这两个式子： \\begin{align} y&=ax^2+bx+c & \\\\ y&=kx & \\\\ \\end{align}然后对代换掉$y$ ax^2+(b-k)\\cdot x+c=0我们需要这两条线没有交点，即 \\begin{align} \\Delta &= (b-k)^2-4ac \\\\ &= b^2-2bk+k^2-4ac \\\\ &= k^2-2bk+b^2-4ac < 0 \\\\ \\end{align}在对这个式子求$\\Delta$ \\Delta \\prime=(-2b)^2-4\\cdot (b^2-4ac)=16ac考虑到$\\Delta$的函数图像是一个开口向上的抛物线，想要有小于$0$的解，那$\\Delta$就必须大于0。用求根公式得出$b-2\\sqrt{ac} &lt; k &lt; b+2\\sqrt{ac}$。 123456789101112131415161718192021222324252627282930313233343536373839404142int n, m;void Main(int kase){ cin&gt;&gt;n&gt;&gt;m; v1(ll) K(n+1), A(m+1), B(m+1), C(m+1); for(int i=1;i&lt;=n;i++) cin&gt;&gt;K[i]; for(int i=1;i&lt;=m;i++) cin&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;C[i]; sort(K.begin()+1, K.end()); for(int i=1;i&lt;=m;i++){ if(A[i]*C[i]&lt;=0){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; continue; } long double mn=B[i]-2*sqrt(A[i]*C[i]), mx=B[i]+2*sqrt(A[i]*C[i]); log(mn, mx, endl); int l=1, r=n, ans=-1; while(l&lt;=r){ int m=(l+r)&gt;&gt;1; if(mn&lt;K[m] &amp;&amp; K[m]&lt;mx){ ans=m; break; }else if(K[m]&lt;=mn){ l=m+1; }else if(K[m]&gt;=mx){ r=m-1; } } if(ans==-1){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; continue; }else{ cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; cout&lt;&lt;K[ans]&lt;&lt;endl; } } cout&lt;&lt;endl;} D. A Wide, Wide Graph根据分析样例（雾），如果一个点到其他点的距离小于$k$，那么这个点和其他点之间就没有边了，他自己会变成一个独立的联通分量。对于一个点，只需要知道这个点到其他点的最大距离，然后对于一个固定的$k$，只要$k&gt;$这个最大距离，就知道这个点被”孤立“了。在$O(n)$的时间内求所有点到其他点的最大距离，需要用到换根$DP$。 tmd好久没写换根了，比赛的时候写了依托答辩。后来查出问题来了，我用了set而没用multiset。。。~~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int n;void calc_depth(int u, int fa, v1(int)&amp; depth_below, v2(int)&amp; G) { for (auto v : G[u]) { if (v == fa) continue; calc_depth(v, u, depth_below, G); depth_below[u] = max(depth_below[u], depth_below[v] + 1); }}void calc_mx_dis(int u, int fa, int dis_fa, v1(int)&amp; mx_dis, v1(int)&amp; depth_below, v2(int)&amp; G) { mx_dis[u] = max(dis_fa + 1, depth_below[u]); multiset&lt;int&gt; MX; for (auto v : G[u]) if (v != fa) MX.insert(depth_below[v]); for (auto v : G[u]) { if (v == fa) continue; MX.erase(MX.find(depth_below[v])); int mx=dis_fa + 1; if(!MX.empty()) mx=max(mx, (*MX.rbegin())+1); calc_mx_dis(v, u, mx, mx_dis, depth_below, G); MX.insert(depth_below[v]); }}void Main(int kase) { cin &gt;&gt; n; v2(int) G(n + 1, v1(int)()); for (int i = 1;i &lt; n;i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); } v1(int) depth_below(n + 1), mx_dis(n + 1); calc_depth(1, 0, depth_below, G); calc_mx_dis(1, 0, -1, mx_dis, depth_below, G); v1(int) num_nodes(n+1); for (int i = 1;i &lt;= n;i++) num_nodes[mx_dis[i]]++; int ans=1; for(int i=1;i&lt;=n;i++){ if(i&gt;1) ans+=num_nodes[i-1]; if(ans==n+1) ans=n; cout&lt;&lt;ans&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}","link":"/2023/04/02/Codeforces-Round-862-1805/"},{"title":"Educational Codeforces Round 145 (1809)","text":"Educational Codeforces Round 145 AC代码 .post-summary { display: none; } A. Garland12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define v1(x) vector&lt;x&gt;#define v2(x) vector&lt;vector&lt;x&gt;&gt;#define v3(x) vector&lt;vector&lt;vector&lt;x&gt;&gt;&gt;using namespace std;typedef long long ll;string input;void Main(int kase){ cin&gt;&gt;input; map&lt;int, int&gt; M; for(int i=0;i&lt;4;i++){ M[input[i]]++; } vector&lt;int&gt; A; for(auto [a, b] : M){ A.push_back(b); } sort(A.begin(), A.end(), [](int a, int b){return a&gt;b;}); if(A[0]==4){ cout&lt;&lt;-1&lt;&lt;endl; }else if(A[0]==3){ cout&lt;&lt;6&lt;&lt;endl; }else{ cout&lt;&lt;4&lt;&lt;endl; }}int main(){ #ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int T; cin&gt;&gt;T; for(int i=1;i&lt;=T;i++) Main(i); return 0;} B. Points on Plane有小坑，$10^{18}$double的精度会不够，用long double就可以解决，我这里直接手写了个二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define v1(x) vector&lt;x&gt;#define v2(x) vector&lt;vector&lt;x&gt;&gt;#define v3(x) vector&lt;vector&lt;vector&lt;x&gt;&gt;&gt;using namespace std;typedef long long ll;ll n;void Main(int kase){ cin&gt;&gt;n; if(n&lt;=1){ cout&lt;&lt;0&lt;&lt;endl; return; } ll l=0, r=1e9, ans1=LLONG_MAX, ans2=LLONG_MAX; while(l&lt;=r){ ll m=(l+r)&gt;&gt;1; ll t=1+4*m*(m-1); if(t&gt;=n){ ans1=min(m, ans1); r=m-1; }else{ l=m+1; } } l=0, r=1e9; while(l&lt;=r){ ll m=(l+r)&gt;&gt;1; ll t=4*m*m; if(t&gt;=n){ ans2=min(m, ans2); r=m-1; }else{ l=m+1; } } cout&lt;&lt;min(2*(ans1-1), ans2*2-1)&lt;&lt;endl; // cout&lt;&lt;2*(ans1-1)&lt;&lt;&quot; &quot;&lt;&lt;ans2*2-1&lt;&lt;endl;}int main(){ #ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int T; cin&gt;&gt;T; for(int i=1;i&lt;=T;i++) Main(i); return 0;} C. Sum on Subarrays1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define v1(x) vector&lt;x&gt;#define v2(x) vector&lt;vector&lt;x&gt;&gt;#define v3(x) vector&lt;vector&lt;vector&lt;x&gt;&gt;&gt;using namespace std;typedef long long ll;int n, k;void Main(int kase){ cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++){ if(i*(i+1)/2&lt;=k &amp;&amp; k&lt;=i*(i+1)/2+i){ for(int j=1;j&lt;=i;j++) cout&lt;&lt;2&lt;&lt;&quot; &quot;; int rest=k-i*(i+1)/2; cout&lt;&lt;-2*i-1+2*rest&lt;&lt;&quot; &quot;; for(int j=1;j&lt;n-i;j++) cout&lt;&lt;-1000&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; return; } } for(int i=1;i&lt;=n;i++) cout&lt;&lt;1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;}int main(){ #ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int T; cin&gt;&gt;T; for(int i=1;i&lt;=T;i++) Main(i); return 0;} D. Binary String Sorting交换操作一定是发生在相邻的两个位置上，其他的位置一定是通过删除来实现的。枚举可能发生交换的位置，预处理前缀$1$和后缀$0$的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define v1(x) vector&lt;x&gt;#define v2(x) vector&lt;vector&lt;x&gt;&gt;#define v3(x) vector&lt;vector&lt;vector&lt;x&gt;&gt;&gt;using namespace std;typedef long long ll;#ifdef DEBUGtemplate &lt;typename T&gt;void __log(const T&amp; t) { cout &lt;&lt; t &lt;&lt; endl; }template &lt;typename T, typename... Args&gt;void __log(const T&amp; t, const Args &amp;... rest) { cout &lt;&lt; t &lt;&lt; &quot; &quot;; __log(rest...); }#define log(args...) __log(args)#else#define log(args...) 6#endifstring input;const ll base = 1e12;void Main(int kase) { cin &gt;&gt; input; int n = input.length(); input = '0' + input; v1(int) pref1(n + 5), surf0(n + 5); for (int i = 1;i &lt;= n;i++) pref1[i] = pref1[i - 1] + (input[i] == '1'); for (int i = n;i &gt;= 1;i--) surf0[i] = surf0[i + 1] + (input[i] == '0'); ll ans = LLONG_MAX; for (int i = 1;i &lt;= n + 1;i++) { ll tempans = 0; if (1 &lt;= i - 1 &amp;&amp; i &lt;= n) if (input[i - 1] == '1' &amp;&amp; input[i] == '0') tempans += base; if (i - 1 &gt; 1)tempans += pref1[i - 2] * (base + 1); if (i &lt; n)tempans += surf0[i + 1] * (base + 1); ans = min(ans, tempans); log(tempans); } cout &lt;&lt; ans &lt;&lt; endl;}int main() {#ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif ios_base::sync_with_stdio(0); cin.tie(0); int T; cin &gt;&gt; T; for (int i = 1;i &lt;= T;i++) Main(i); return 0;} E. Two Tanks1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define v1(x) vector&lt;x&gt;#define v2(x) vector&lt;vector&lt;x&gt;&gt;#define v3(x) vector&lt;vector&lt;vector&lt;x&gt;&gt;&gt;#define read_temp(x) int x; cin&gt;&gt;x;// #define min(args...) min({args})// #define max(args...) max({args})#define endl '\\n'#ifdef DEBUGtemplate &lt;typename T&gt;void __log(const T&amp; t) { cout &lt;&lt; t &lt;&lt; endl; }template &lt;typename T, typename... Args&gt;void __log(const T&amp; t, const Args &amp;... rest) { cout &lt;&lt; t &lt;&lt; &quot; &quot;; __log(rest...); }#define log(args...) __log(args)#else#define log(args...) 6#endif// #define MULTIPLE_CASESint n, a, b;void Main(int kase) { cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; v1(int) V(n); v2(int) ans(a + 1, v1(int)(b + 1)); for (int i = 0;i &lt; n;i++) cin &gt;&gt; V[i]; for (int cd = 0;cd &lt;= a + b;cd++) { int l = max(0, cd - b), r = min(a, cd); int sum = 0; for (auto x : V) { sum += x; l = max({l, sum, sum + cd - b}); r = min({r, sum + a, sum + cd}); } if (l &gt; r) l = r = max(0, cd - b); int res = l; for (int x : V) { if (x &gt; 0) res -= min({res, x, b - (cd - res)}); else res += min({cd - res, -x, a - res}); } for (int c = 0;c &lt;= cd;c++) { if (c &lt;= a &amp;&amp; cd - c &lt;= b) ans[c][cd - c] = c &lt; l ? res : c &gt; r ? res + r - l : res + c - l; } } for (int i = 0;i &lt;= a;i++) { for (int j = 0;j &lt;= b;j++) { cout &lt;&lt; ans[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; }}int main() {#ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 0;#ifdef MULTIPLE_CASES int T; cin &gt;&gt; T; while (++t &lt;= T)#endif Main(t); return 0;} F. Traveling in Berland123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pii pair&lt;int, int&gt;#define pll pair&lt;ll, ll&gt;#define v1(x) vector&lt;x&gt;#define v2(x) vector&lt;vector&lt;x&gt;&gt;#define v3(x) vector&lt;vector&lt;vector&lt;x&gt;&gt;&gt;#define read_temp(x) int x; cin&gt;&gt;x;#define min(args...) min({args})#define max(args...) max({args})#define endl '\\n'#ifdef DEBUGtemplate &lt;typename T, enable_if_t&lt;is_same_v&lt;T, char&gt;, bool&gt; = true&gt;void __output(T t) { cout &lt;&lt; t &lt;&lt; (t == '\\n' ? &quot;&quot; : &quot; &quot;); }template &lt;typename T, typename... Args, enable_if_t&lt;not is_same_v&lt;T, char&gt;, bool&gt; = true&gt;void __output(T t) { cout &lt;&lt; t &lt;&lt; &quot; &quot;; }void __log() { cout &lt;&lt; flush; }template &lt;typename T, typename... Args&gt;void __log(T t, Args... rest) { __output(t); __log(rest...); }#define log(args...) if(LOG_OUTPUT) __log(args)#else#define log(args...) 6#endif#define LOG_OUTPUT 1#define MULTIPLE_CASESll n, k;void Main(int kase) { cin &gt;&gt; n &gt;&gt; k; ll all2 = 1; v1(ll) A(2 * n + 1), B(2 * n + 1), mp(2 * n + 1); for (ll i = 1;i &lt;= n;i++) cin &gt;&gt; A[i], A[i + n] = A[i]; for (ll i = 1;i &lt;= n;i++) { cin &gt;&gt; B[i], B[i + n] = B[i]; if (B[i] == 1) all2 = 0; } for (ll i = 2 * n;i &gt;= 2;i--) A[i] = A[i - 1]; A[1] = 0; for (ll i = 1;i &lt;= 2 * n;i++) A[i] += A[i - 1]; if (all2) { for (ll i = 1;i &lt;= n;i++) { cout &lt;&lt; (A[i + n] - A[i]) * 2 &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return; } v1(ll) V1(1); for (ll i = 1;i &lt;= 2 * n;i++) if (B[i] == 1) mp[i] = V1.size(), V1.push_back(A[i]); ll n1 = V1.size() - 1; v2(ll) bl(n1, v1(ll)(20)); for (ll i = 1;i &lt; n1;i++) bl[i][0] = V1[i + 1] - V1[i] &lt;= k ? V1[i + 1] - V1[i] : k + (V1[i + 1] - V1[i] - k) * 2; for (ll j = 1, base = 1;j &lt;= 19;j++, base *= 2) for (ll i = 1;i &lt; n1 &amp;&amp; i + base &lt; n1 &amp;&amp; bl[i][j - 1] != 0 &amp;&amp; bl[i + base][j - 1] != 0;i++) bl[i][j] = bl[i][j - 1] + bl[i + base][j - 1]; v1(ll) pre1(2 * n + 1), nxt1(2 * n + 1); ll pos1 = -1; for (ll i = 1;i &lt;= 2 * n;i++) { if (B[i] == 1) pos1 = i; pre1[i] = pos1; } pos1 = -1; for (ll i = 2 * n;i &gt;= 1;i--) { if (B[i] == 1) pos1 = i; nxt1[i] = pos1; } for (ll i = 1;i &lt;= n;i++) { ll start1 = nxt1[i], end1 = pre1[i + n]; ll ans = 0; ans += 2 * (A[start1] - A[i]); ans += A[i + n] - A[end1] &lt;= k ? A[i + n] - A[end1] : k + (A[i + n] - A[end1] - k) * 2; if (end1 == start1) { cout &lt;&lt; ans &lt;&lt; &quot; &quot;; continue; } ll dis = mp[end1] - mp[start1], j = 0, cur = mp[start1], base = 1; while (dis) { if (dis % 2) { ans += bl[cur][j]; cur += base; } dis /= 2; base *= 2; j++; } cout &lt;&lt; ans &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl;}int main() {#ifdef DEBUG freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 0;#ifdef MULTIPLE_CASES int T; cin &gt;&gt; T; while (++t &lt;= T)#endif Main(t); cout &lt;&lt; flush; return 0;}","link":"/2023/04/01/Educational-Codeforces-Round-145-1809/"},{"title":"GAMES106笔记","text":"GAMES 106的笔记 课程链接 .post-summary { display: none; } 课内笔记0.作业0.这个作业已经给了一个写好的框架，只需要用cmake build一下就好了。 用github把原来的仓库fork一份之后，clone到本地。 为了保证cmake出来的文件不会造成太多的混淆，我在目录下新建了一个build文件夹来存放cmake构建出来的东西。 然后运行cmake .. -G &quot;MinGW Makefiles&quot;，这里的-G &quot;MinGW Makefiles&quot;是指定cmake出来的东西可以用mingw32-make编译。 cmake生成好编译文件之后用mingw32-make进行编译：mingw32-make 然后就很高兴地报错了： 12games106\\base\\VulkanDebug.h:23:10: fatal error: glm/glm.hpp: No such file or directory #include &lt;glm/glm.hpp&gt; 打开项目根目录下的Cmakelist.txt看了下：include_directories(external/glm)，这说明glm应该是被放在games106/external/glm这个目录下，但是这个目录是空的。 去GLM官网下好这个包，解压之后按照报错的头文件位置解压进去就好了。 还有一个错： 12games106\\base\\vulkanexamplebase.h:16:10: fatal error: ShellScalingAPI.h: No such file or directory #include &lt;ShellScalingAPI.h&gt; 这个错误是mingw-w64版本太低导致的，我从8.1.0升级到12.1.0之后就好了。 编译好之后就好了，生成的可执行程序在新建的build目录下的bin目录里面。 （4610帧属实有点6）","link":"/2023/04/07/GAMES106%E7%AC%94%E8%AE%B0/"},{"title":"Linux &amp; VirtualBox使用手册","text":"Linux和VirtualBox中的常用但是容易忘记的命令和操作 .post-summary { display: none; } 在VirtualBox中挂载共享文件夹1sudo mount -t vboxsf Share share_dir 在这个VirtualBox共享文件的设置下，命令应当是这个： 1sudo mount -t vboxsf shared_windows /home/liujio/shared Ubuntu中安装zsh和oh-my-zsh检查当前机器下的shcat /etc/shells如果有zsh，就不需要额外安装了 安装zsh1234apt install zsh #安装zshchsh -s /bin/zsh #将zsh设置成默认shell（不设置的话启动zsh只有直接zsh命令即可）# 或者sudo修改/etc/passwd 安装oh-my-zsh1wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 安装插件1234#zsh-autosuggestions 命令行命令键入时的历史命令建议git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions#zsh-syntax-highlighting 命令行语法高亮插件git clone https://gitee.com/Annihilater/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 配置文件~/.zshrc123456789101112131415# 启动错误命令自动更正ENABLE_CORRECTION=&quot;true&quot;# 在命令执行的过程中，使用小红点进行提示COMPLETION_WAITING_DOTS=&quot;true&quot;# 配置要使用的插件plugins=( git extract zsh-autosuggestions zsh-syntax-highlighting)source $ZSH/oh-my-zsh.shsource $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh 安装powerlevel10k主题1git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 在 zshrc中设置ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; Ubuntu下安装中文输入法首先先整题更新一下系统sudo apt update 然后必须事先先安装好中文语言包, 如果出错也可以用命令行安装sudo apt install language-pack-zh-hans 随后将Keyboard Input System设置成fcitx 最后需要配置一下fcitx","link":"/2022/12/03/Linux-&-VirtualBox%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"},{"title":"Effiziente Algorithmen und Datenstrukturen II","text":"EA2的笔记 （感谢fy的课后辅导） .post-summary { display: none; } Introduction to Linear Programming (LP)给定$m$个对于$n$个自变量的约束条件, 要求在满足这些约束条件的前提下, 最大化收益. 标准的LP形式: \\begin{aligned} & \\max \\left( \\sum_{j=1}^n c_j x_j \\right) \\\\ & \\text { s.t. } \\sum_{j=1}^n a_{i j} x_j=b_i \\quad 1 \\leq i \\leq m \\\\ & x_j \\geq 0 \\quad 1 \\leq j \\leq n \\\\ & \\end{aligned}以数组的形式: \\begin{aligned} \\max & \\left(c^T x\\right) \\\\ \\text { s.t. } & A x=b \\\\ & x \\geq 0 \\end{aligned}其中$Ax=b$指出了自变量$x$需要满足的条件, 而$c^Tx$就是收益计算方式, 他给每一个自变量$x_j$一个权值$c_j$. 当然, LP也有除了等号的标准形式: 求最小值: $\\begin{array}{rr} &amp; \\min \\left( c^T x \\right) \\ &amp; \\text { s.t. } A x=b \\ &amp; x \\geq 0\\end{array}$ 最大化约束: $\\begin{array}{rr} &amp; \\max \\left( c^T x \\right) \\ &amp; \\text { s.t. } A x \\leq b \\ &amp; x \\geq 0\\end{array}$ 最小化约束: $\\begin{array}{rr} &amp; \\max \\left( c^T x \\right) \\ &amp; \\text { s.t. } A x \\geq b \\ &amp; x \\geq 0\\end{array}$ 我们可以很容易地从一个形式转换成另一个形式: 小于等于变等于: $a-3 b+5 c \\leq 12 \\Rightarrow \\begin{aligned} a-3 b+5 c+s &amp; =12 \\ s &amp; \\geq 0\\end{aligned}$ 大于等于变等于: $a-3 b+5 c \\geq 12 \\Rightarrow \\begin{aligned} a-3 b+5 c-s &amp; =12 \\ s &amp; \\geq 0\\end{aligned}$ 最小值转最大值: $\\min \\left( a-3 b+5 c \\right) \\Rightarrow \\max \\left( -a+3 b-5 c \\right)$ 等于转小于等于: $a-3 b+5 c=12 \\Rightarrow \\begin{gathered}a-3 b+5 c \\leq 12 \\ -a+3 b-5 c \\leq-12\\end{gathered}$ 等于转大于等于: $a-3 b+5 c=12 \\Rightarrow \\begin{gathered}a-3 b+5 c \\geq 12 \\ -a+3 b-5 c \\geq-12\\end{gathered}$ 未限制转非负: $x$ unrestricted $\\Rightarrow x=x^{+}-x^{-}, x^{+} \\geq 0, x^{-} \\geq 0$ 只要是新加的变量都有非负的限制条件, 这是因为自变量$x_j$必须是非负的 Definition 1 (Linear Programming Problem (LP))已知 $A \\in \\mathbb{Q}^{m \\times n}, b \\in \\mathbb{Q}^m, c \\in \\mathbb{Q}^n, \\alpha \\in \\mathbb{Q}$, 问是否存在 $x \\in \\mathbb{Q}^n$ s.t. $A x=b, x \\geq 0$, 使得 $ c^T x \\geq \\alpha$ ? LP $\\in$ NP / co-NP / P ? LP是NP问题吗？ LP是co-NP问题吗？ LP是P问题吗？ 输入$n$是自变量的数量, $m$是约束条件的数量, $L$是编码输入需要的bit. LP的几何意义 一些额外的定义对于一个满足条件的自变量的集合 $P={x \\mid A x=b, x \\geq 0}$: $P$ 被称作可行域(feasible region) $P$ 中的一个点$x \\in P$被称作可行解(feasible point) 如果 $P \\neq \\varnothing$ , 那这个LP就被称作可解的(feasible), 否则就是无解的(infeasible) LP是有界的(bounded)如果它是有解的并且 所有可行解 $x \\in P$ , $c^T x&lt;\\infty$ 所有可行解 $x \\in P$ , $c^T x&gt;-\\infty$ Definition 2给定向量或者点 $x_1, \\ldots, x_k \\in \\mathbb{R}^n$ , $\\sum \\lambda_i x_i$: 线性组合(linear combination), 如果 $\\lambda_i \\in \\mathbb{R}$ 仿射组合(affine combination), 如果 $\\lambda_i \\in \\mathbb{R}$ 并且 $\\sum_i \\lambda_i=1$ 凸组合(convex combination), 如果 $\\lambda_i \\in \\mathbb{R}$, $\\sum_i \\lambda_i=1$ 并且 $\\lambda_i \\geq 0$ 锥组合(conic combination), 如果 $\\lambda_i \\in \\mathbb{R}$ 并且 $\\lambda_i \\geq 0$ 组合中的向量或者点的个数必须是有限的!!! Definition 3 &amp; 4集合$X \\subseteq \\mathbb{R}^n$是: $span(X)$ : 线性子空间(linear subspace), 如果它在线性组合下是个闭集(closed set) $aff(X)$ : 仿射子空间(affine subspace), 如果它在仿射组合下是个闭集 $conv(X)$ : 凸包(convex), 如果它在凸组合下是个闭集 $cone(X)$ : $凸锥(convex cone), 如果它在锥组合下是个闭集 仿射子空间可能不是一个向量空间, 因为它有可能不过原点!!! 人话 线性子空间和凸包是已经熟知的概念, 这里提一下对于仿射子空间和凸锥的通俗理解: 仿射子空间对于一个二维平面, 两个点的仿射子空间就是过这两个点的直线, 此时它是一个一维的概念. 但是如果加入了第三个不共线的点, 此时这三个点的仿射子空间就是整个二维平面了. 由此我推断一个集合的仿射子空间是一个能过所有点的最低维度空间. 凸锥可以理解成从原点发射的所有能打中凸包的射线组成的集合体, 确实是一个锥的样子, 很形象 Definition 5函数 $f: \\mathbb{R}^n \\rightarrow \\mathbb{R}$ 是(向下)凸(convex)的, 如果对于所有的 $x, y \\in \\mathbb{R}^n$ 和 $\\lambda \\in[0,1]$ , 满足如下: f(\\lambda x+(1-\\lambda) y) \\leq \\lambda f(x)+(1-\\lambda) f(y)Lemma 6如果 $P \\subseteq \\mathbb{R}^n$ , $f: \\mathbb{R}^n \\rightarrow \\mathbb{R}$ 是凸的, 那么 $Q={x \\in P \\mid f(x) \\leq t}$ 也是凸的 ? Definition 7仿射子空间 $A \\subseteq \\mathbb{R}^n$ 的维数 $dim(A)$ , 是在 $A$ 中任取一点 $a \\in A$ 后, 向量空间 ${x-a \\mid x \\in A}$ 的维数. 人话 把仿射子空间平移到原点之后的空间的维数. Definition 8对于集合 $X \\subseteq \\mathbb{R}^n$ , $dim(X)$ 的维数和 $aff(X)$ 的维数相同. Definition 9集合 $H \\subseteq \\mathbb{R}^n$ 是一个超平面(hyperplane), 如果存在向量 $a \\neq 0$ , $H={x \\mid a^T x=b}$. 人话 $a$ 是比当前空间低一维的维度的法向量的方向. 例如: 当前空间是二维平面, 那么 $a$ 就是直线的法向量 ; 当前空间是三维空间, 那么 $a$ 就是平面的法向量. $b$ 是比当前空间低一维的维度的截距, 这是一个有向距离. Definiation 10集合 $H^{\\prime} \\subseteq \\mathbb{R}^n$ 是一个(闭)半空间, 如果存在向量 $a \\neq 0$ , $H={x \\mid a^T x \\leq b}$ 人话 $a$ 的反方向, 以超平面为界的维度空间 Definition 11polytop是一个集合 $P \\subseteq \\mathbb{R}^n$ , 满足 $P=\\operatorname{conv}(X)$ , $|X|=c$. Definition 12polyhedron是一个集合 $P \\subseteq \\mathbb{R}^n$ , 这个集合可以被表示成若干个半空间的交集 ${H\\left(a_1, b_1\\right), \\ldots, H\\left(a_m, b_m\\right)}$, $H\\left(a_i, b_i\\right)={x \\in \\mathbb{R}^n \\mid a_i x \\leq b_i}$ Definition 13polyhedron $P$ 是有界的(bounded), 如果所有 $x \\in P$ , 存在 $B$ , 使得 $|x|_2 \\leq B$ Theorem 14$P$ 是一个有界的polyhedron $\\iff$ $P$ 是一个polytop Definition 15给定 $P \\subseteq \\mathbb{R}^n, a \\in \\mathbb{R}^n$ 和 $b \\in \\mathbb{R}$. 超平面 $H(a, b)={x \\in \\mathbb{R}^n \\mid a^T x=b}$ 是一个 支撑超平面(supporting hyperplane), 如果 $\\max {a^T x \\mid x \\in P}=b$ 人话 那些贴在凸包上的超平面 Definition 16给定 $P \\subseteq \\mathbb{R}^n$. $F$ 是一个 $P$ 的face, 如果 $F=P$ 或者对于一些支撑超平面 $H$ , $F=P \\cap H$ . Definition 17给定 $P$ : $v$ 是 $P$ 的一个端点(vertex), 如果 ${ v }$ 是 $P$ 的face $e$ 是 $P$ 的一条边(edge), 如果 $e$ 是 $P$ 的face, 并且 $dim(e)=1$ $F$ 是 $P$ 的一个面(facet), 如果 $F$ 是 $P$ 的face, 并且 $dim(F)=dim(P)-1$ Definition 18另一种vertex的判断方法: 给定一个polyhedron $P$. 一个点 $x \\in P$ 是一个端点(vertex), 如果对于所有的 $y \\in P, y \\neq x$, $\\exists c \\in \\mathbb{R}^n$ 满足 $c^T y&lt;c^T x$ Definition 19给定一个polyhedron $P$. 一个点 $x \\in P$ 是一个极值点(extreme point), 如果 $\\nexists a, b \\neq x, a, b \\in P$, 满足 $\\lambda a+(1-\\lambda) b=x$ for $\\lambda \\in[0,1]$. 人话 不存在与 $x$ 共线并且在 $x$ 两侧的点 $a$ 和 $b$ Definition 20端点是极值点 ObservationLP的可行域是一个ployhedron Theorem 21如果标准形式的LP存在最优解, 那么一定存在一个是极值点的最优解 证明 如果 $x$ 是一个非极值点的最优解 假设有一个向量 $d \\neq 0$ , $x \\pm d \\in P$ $\\Rightarrow A \\cdot (x \\pm d)=b \\Rightarrow A \\cdot d=0$ 在 $d$ 和 $-d$ 中取一个使 $c^T \\cdot d’ &gt; 0 \\quad (d’ = d \\text{ or } -d)$ 的, 作为正方向 $d$. 这是一定可以取到的, 因为 $d \\neq 0$ , 若 $c^T \\cdot d &lt; 0$, 那么 就一定有 $c^T \\cdot d &gt; 0$ 现在考虑从 $x$ 出发, 在射线 $x$ 到 $x+d$ 上的点 : $x+\\lambda d, \\lambda&gt;0$ Case 1: $\\exists j$ s.t. $d_j&lt;0$ ? Notation$B \\subseteq{1 \\ldots n}$ 是列索引的集合, $A_B$是 $A$ 中索引在 $B$ 里的列的集合 Theorem 22给定集合 $P={x \\mid A x=b, x \\geq 0}$. 对于一个 $x \\in P$, 定义 $B={j \\mid x_j&gt;0}$. 那么 $x$ 是极值点当且仅当 $A_B$ 有线性无关的列. 对于向量 $v1, v_2, … , v_n$ , 若是存在 $a_1, a_2, … , a_n$ , 使得 $\\sum{i=1}^n a_i \\cdot v_i = 0$ , 则称向量 $v_1, v_2, … , v_n$ 线性相关, 否则向量 $v_1, v_2, … , v_n$ 线性无关 证明 $\\Leftarrow$假设 $x$ 不是极值点 那就存在一个向量 $d \\neq 0$ , 使得 $x \\pm d \\in P$ $\\Rightarrow A \\cdot (x \\pm d)=b \\Rightarrow A \\cdot d=0 \\Rightarrow A\\text{ 中的列是线性相关的}$ 定义 $B^{\\prime}={j \\mid d_j \\neq 0}$ 根据矩阵乘法, $A \\cdot d = \\sum_i \\text{A的第} i \\text{列} \\cdot d_i$ , 而如果 $d$ 的第 $i$ 个元素是 $0$, 那么他就不会对结果产生贡献. 所以 $A \\cdot d$ 的结果其实就是 $A_{B’}$ 中的列依次去乘 $d$ 中的非零元素 (这两者的数量应该是相等的), 乘出来的结果也是 $0$ 所以 $A_{B’}$ 的列也是线性相关的 如果对于某个索引 $j$ , $x_j=0 \\Rightarrow d_j=0$ , 这是因为有 $x_j \\geq 0$ 这个条件. 因此 $B^{\\prime} \\subseteq B$ , 所以 $A_B$ 的列也必然是线性相关的 $\\Rightarrow$假设 $x$ 是极值点的时候, $A_B$ 是线性相关的 那么就必定存在 $d \\neq 0$ , 使得 $A_B \\cdot d=0$ 将 $d$ 扩展到 $\\mathbb{R}^n$ (原本 $d$ 中是只含有 $B$ 中的位置的值的, 现在给其他位置填充 $0$ ) 那么 $A \\cdot d = 0$ 所以对于足够小的 $\\lambda$ 有 $x \\pm \\lambda d \\in P$ , 因此 $x$ 不是一个极值点, 与假设矛盾 Theorem 23给定 $P={x \\mid A x=b, x \\geq 0}$ , 对任意 $x \\in P$ , 我们定义 $B={j \\mid x_j&gt;0}$ . 如果 $A_B$ 的列是线性无关的, 则 $x$ 是 $P$ 的一个端点(vertex). 结合Theorem 22, 说明在 $A_B$ 行满秩的前提下, 端点和极值点其实是等价的 证明 定义 $c_j= \\begin{cases}0 &amp; j \\in B \\ -1 &amp; j \\notin B\\end{cases}$ 则 $c^T \\cdot x=0$ , 对于其他点 $y \\in P$ , $c^T \\cdot y \\le 0$ (因为 $c$ 是非正的) 根据端点的定义(Definition 18), 如果 $x$ 是端点, 我们必须证明: $\\forall y, c^T \\cdot y = 0 \\Rightarrow x=y$ 我们假设 $c^T y=0$ , 则如果 $j \\notin B$ , $y_j=0$ 必须满足, 否则结果里面就会出现 $-1$ 因为 $y \\in P$ , 所以有 $Ay=b$ , 对于 $y$ 中不属于 $B$ 的索引对应的元素, 不会对结果产生贡献, 因为他们是 $0$ , 所以有 $Ay=b=A_B \\cdot y_B$ . 对于 $x$ 中不属于 $B$ 的索引对应的元素同理. 所以有 $Ay=b=A_B \\cdot y_B = Ax=A_B \\cdot x_B$ 移项之后能得出: $A_B\\left(x_B-y_B\\right)=0$ 因为 $A$ 的列是线性无关的, 所以 $x_B - y_B$ 一定得是 $0$ (线性无关的定义) 于是就证出了 $\\forall y, c^T \\cdot y = 0 \\Rightarrow x=y$ 所以在 $A_B$ 的列是线性无关的条件下, 对于我们构建的 $c$ , $\\nexists y \\neq x , c^T \\cdot y \\ge c^T \\cdot x$ , 所以 $x$ 必定是端点. Observation对于一个LP问题, 我们能够假设矩阵 $A$ 是行满秩的, 即 $\\operatorname{rank}(A)=m$ 从现在开始, 我们假设标准形式的LP问题的条件矩阵 $A$ 都是行满秩的 说明 假设 $\\operatorname{rank}(A)&lt;m$ 不失一般性, 我们假设第一行 $A_1$ 能够表示成其他列 $A_2, \\ldots, A_m$ 的线性组合: A_1=\\sum_{i=2}^m \\lambda_i \\cdot A_iCase 1如果 $b1=\\sum{i=2}^m \\lambda_i \\cdot b_i$ , 则第一行就没意义了, 如果除了第一行的其他行能够成立, 那么第一行必定成立 Case 2如果 $b1 \\neq \\sum{i=2}^m \\lambda_i \\cdot b_i$ , 那么LP就是无解的, 因为: A_1 x=\\sum_{i=2}^m \\lambda_i \\cdot A_i x=\\sum_{i=2}^m \\lambda_i \\cdot b_i \\neq b_1即如果第一行成立, 则其他行不成立; 如果其他行成立, 则第一行必不成立 Theorem 24给定 $P={x \\mid A x=b, x \\geq 0}$ , $x$ 是极值点当且仅当存在 $B \\subseteq{1, \\ldots, n}$ , 满足 $|B|=m$ 并且: $A_B$ 是非奇异的 $x_B=A_B^{-1} b \\geq 0$ $x_N=0$ 定义 $N={1, \\ldots, n} \\backslash B$ 证明 $\\Rightarrow$根据Theorem 22, 如果 $x$ 是极值点, 则存在 $B={j \\mid x_j&gt;0}$ , 使得 $A_B$ 的列是线性无关的. $max\\left(|B|\\right)=m$ , 因为 $A$ 是行满秩的, 即 $rank(A)=m$ , 并且行秩等于列秩, 所以列秩最大就是 $m$ , 即最多有 $m$ 个线性无关的列. 如果 $|B|&lt;m$ , 我们就往里面加入线性无关的列即可. 易得, 这样构造出的 $B$ 和 $A_B$ 是满足条件的 $\\Leftarrow$上述过程都是充要并且可逆的, 反过来写就好了 Basic Feasible Solutions如果 $x \\in \\mathbb{R}^n$ , $A x=b$ 并且定义 $J={j \\mid x_j \\neq 0}$ , $\\operatorname{rank}\\left(A_J\\right)=|J|$ , 则 $x$ 被称作基本解 (basis solution). 如果 $x$ 是一个基本解, 并且 $x \\ge 0$ , 那么 $x$ 被称作基本可行解 (basic feasible solution) 一个底 (basis) 是一个索引集 $B \\subseteq{1, \\ldots, n}$ , 满足 $\\operatorname{rank}\\left(A_B\\right)=m$ 并且 $|B|=m$ 给定底 $B$ , 满足 $A_B x_B=b$ , 并且对于所有 $j \\notin B$ , $x_j=0$ 的 $x \\in \\mathbb{R}^n$ 被称作关联底 $B$ 的基本解 根据Theorem 22, Theorem 23和Theorem 24, 我们知道任何关联底 $B$ 的基本都是一个极值点和端点. Facts一个基本可行解满足了约束矩阵 $A$ 中的 $m$ 个等号约束 除此之外, 索引不在底 $B$ 中的 $x$ 的元素 $x_j$ 的值是 $0$ , 因此 $x \\ge 0$ 的 $n$ 个非负约束中的 $n-m$ 个被等号满足. 也就是说, 一个基本可行解能等号满足至少 $n$ 个约束 Definition 25基于上述Facts, 对于一个有 $n$ 个变量的通用LP ($\\max {c^T x \\mid A x \\leq b}$) , $x$ 是一个基本可行解如果 $x$ 是可行的并且存在 $n$ 个 (线性无关的) 约束是被等号满足的 (tight) Illustration 其中蓝色的是基本可行解, 红色的是基本解 Fundamental QuestionsIs LP in NP? yes! 因为给定一个底 $B$ , 我们能在多项式时间内计算出他对应的基本解 $A_B^{-1} b$ NP is the set of decision problems for which the problem instances, where the answer is “yes”, have proofs verifiable in polynomial time by a deterministic Turing machine, or alternatively the set of problems that can be solved in polynomial time by a nondeterministic Turing machine. Observation我们能在 $\\mathcal{O}\\left(\\left(\\begin{array}{c}n \\ m\\end{array}\\right) \\cdot \\operatorname{poly}(n, m)\\right)$ 的时间复杂度内计算出最优解 证明 最多只有 $\\left(\\begin{array}{c}n \\ m\\end{array}\\right)$ 个底, 便利一次计算出最优解即可 如果LP不是有界的, 那么把要求(证)的那个 $c^Tx \\leq \\alpha$ 也加进去, 就能转换成有界的LP了 Simplex AlgorithmIdea如果便利所有的基本可行解来求最优解太慢了 我们只需要从一个基本可行解开始, 经过与他相邻 (adjacent) 的基本可行解, 保证目标函数 (objective function) 不减少 两个基本可行解是相邻的, 如果他们对应的底只有一个变量不同 Pivoting Step (Example) \\begin{array}{rcrcrcrcrcl} \\max \\quad 13 a & +&23 b \\\\ \\text { s.t. } \\quad 5a & + & 15b & + & s_c & & & & & = & 480 \\\\ 4a & + & 4b & & & + & s_h & & & = & 160 \\\\ 35a & + & 20b & & & & & + & s_m & = & 1190 \\\\ a & , & b & , & s_c & , & s_h &, & s_m & \\geq & 0 \\end{array}先进行一次小小的变形, 我们要保证在底中的变量 ( ${s_c, s_h, s_m}$ ) 的系数必须是 $1$ , 否则进行一次高斯消元 约束矩阵 状态 $\\begin{array}{rcrcrcrcrcrcl} \\max \\quad Z \\\\ \\text { s.t. } \\quad 13 a &amp; + &amp;23 b &amp; &amp; &amp; &amp; &amp; &amp; &amp; - &amp; Z &amp; = &amp; 0 \\\\ 5a &amp; + &amp; 15b &amp; + &amp; s_c &amp; &amp; &amp; &amp; &amp; &amp; &amp; = &amp; 480 \\\\ 4a &amp; + &amp; 4b &amp; &amp; &amp; + &amp; s_h &amp; &amp; &amp; &amp; &amp; = &amp; 160 \\\\ 35a &amp; + &amp; 20b &amp; &amp; &amp; &amp; &amp; + &amp; s_m &amp; &amp; &amp; = &amp; 1190 \\\\ a &amp; , &amp; b &amp; , &amp; s_c &amp; , &amp; s_h &amp;, &amp; s_m &amp; &amp; &amp; \\geq &amp; 0 \\end{array} $ $\\begin{aligned} &amp; \\text {basis}={s_c, s_h, s_m} \\\\ &amp; a=b=0 \\\\ &amp; Z=0 \\\\ &amp; s_c=480 \\\\ &amp; s_h=160 \\\\ &amp; s_m=1190\\end{aligned}$ 这样我们的目标函数就是约束矩阵的第一行了 接下来我们从目标函数中取一个不在底中的并且系数是正的变量(必须是最大的那个, 否则会死循环), 这个例子中可供选择的有 ${a, b}$ , 但是 $b$ 的系数更大, 所以我们选 $b$ , 这变量叫做进入变量 (entering variable) 接下来我们保持 $a=0$ 不变, 增大 $b$ , 因为要维护约束约束矩阵, 所以底中的变量会变小, 我们增大 $b$ 到 $\\theta$ 使得有一个底中的变量减小到了 $0$ (不可能有两个, 因为约束矩阵 $A$ 是行满秩的, 如果有两个的话说明 $A$ 的行是线性相关的, 就不是行满秩的了) 这里我们可以很容易的算出 $\\theta=\\min {480 / 15,160 / 4,1190 / 20}$ , 因为底中的变量的系数都是1 第一个被减到 $0$ 的底中的变量是 $s_c$ , 这个变量叫做离开变量 (leaving variable) 得到了进入变量和离开变量, 我们要对约束矩阵进行变换: 在除了第一行 (目标函数) 的行中, 首先将进入变量的系数变为 $1$ 找到进入变量和离开变量都存在的那行, 消去除了这行的所有行中的进入变量 (这一步的目的是消去其他行不是底中的变量, 让底中的变量只出现一次) 更改状态, 将离开变量从底中剔除, 加入进入变量, 根据求得的 $\\theta$ 改变变量的值 约束矩阵 状态 $ \\begin{array}{rcrcrcrcrcrcl} \\max \\quad Z \\\\ \\text { s.t. } \\quad \\frac {16}{3} a &amp; &amp; &amp; - &amp; \\frac{23}{15} s_c &amp; &amp; &amp; &amp; &amp; - &amp; Z &amp; = &amp; -736 \\\\ \\frac{1}{3}a &amp; + &amp; b &amp; + &amp; \\frac{1}{15}s_c &amp; &amp; &amp; &amp; &amp; &amp; &amp; = &amp; 32 \\\\ \\frac{8}{3} a &amp; &amp; &amp; - &amp; \\frac{4}{15}s_c &amp; + &amp; s_h &amp; &amp; &amp; &amp; &amp; = &amp; 32 \\\\ \\frac{85}{3} a &amp; &amp; &amp; - &amp; \\frac{4}{3}s_c &amp; &amp; &amp; + &amp; s_m &amp; &amp; &amp; = &amp; 550 \\\\ a &amp; , &amp; b &amp; , &amp; s_c &amp; , &amp; s_h &amp;, &amp; s_m &amp; &amp; &amp; \\geq &amp; 0 \\end{array} $ $\\begin{aligned} &amp; \\text {basis}={b, s_h, s_m} \\\\ &amp; a=s_c=0 \\\\ &amp; Z=736 \\\\ &amp; b=32 \\\\ &amp; s_h=32 \\\\ &amp; s_m=550\\end{aligned}$ 重复以上步骤知道目标函数中的系数都是负的. 剩下的步骤 这里再走一步: 目标函数中现在只有 $a$ 的系数是负的, 所以我们选择 $a$ 作为进入变量 然后计算 $\\theta = \\min {3 \\cdot 32,3 \\cdot 32 / 8,3 \\cdot 550 / 85}$ , 这里最小的是第三项, 所以我们选 $s_m$ 作为离开变量 约束矩阵 状态 $ \\begin{array}{rcrcrcrcrcrcl} \\max \\quad Z \\\\ \\text { s.t. } \\quad \\&amp; &amp; &amp; - &amp; \\frac{23}{15} s_c &amp; &amp; - &amp; 2s_h &amp; &amp; &amp; - &amp; Z &amp; = &amp; -800 \\\\ &amp; + &amp; b &amp; + &amp; \\frac{1}{10}s_c &amp; - &amp; \\frac{1}{8}s_h &amp; &amp; &amp; &amp; &amp; = &amp; 28 \\\\ a &amp; &amp; &amp; - &amp; \\frac{1}{10}s_c &amp; + &amp; \\frac{3}{8}s_h &amp; &amp; &amp; &amp; &amp; = &amp; 12 \\\\ &amp; &amp; &amp; &amp; \\frac{2}{3}s_c &amp; - &amp; \\frac{85}{8}s_h &amp; + &amp; s_m &amp; &amp; &amp; = &amp; 210 \\\\ a &amp; , &amp; b &amp; , &amp; s_c &amp; , &amp; s_h &amp;, &amp; s_m &amp; &amp; &amp; \\geq &amp; 0 \\end{array} $ $\\begin{aligned} &amp; \\text {basis}={a, b, s_m} \\\\ &amp; s_c=s_h=0 \\\\ &amp; Z=800 \\\\ &amp; b=28 \\\\ &amp; a=12 \\\\ &amp; s_m=210\\end{aligned}$ 此时目标矩阵中的变量的系数全是负的了, 所以程序结束, 我们找到的最优解是 $800$ Matrix View \\begin{array}{rcrcl} c_B^T x_B & + & c_N^T x_N & = & Z \\\\ A_B x_B & + & A_N x_N & = & b \\\\ x_B & , & x_N & \\geq & 0 \\end{array}按照上面说的, 需要把底中的变量的系数变成 $1$ , 并且在约束矩阵中只能出现一次: \\begin{array}{rcrcl} & & \\left(c_N^T-c_B^T A_B^{-1} A_N\\right) x_N & = & Z-c_B^T A_B^{-1} b \\\\ x_B & + & A_B^{-1} A_N x_N & = & A_B^{-1} b \\\\ x_B & , & x_N & \\geq & 0 \\end{array}那么基本可行解就是由 $x_N=0, x_B=A_B^{-1} b$ 组成 如果 $\\left(c_N^T-c_B^T A_B^{-1} A_N\\right) \\leq 0$ , 我们就知道我们已经找到最优解了 Geometric View of Pivoting 一开始的底在原点, 然后往上走了一步, 再往右走了一步到达最优解 Algebraic Definition of Pivoting给定底 $B$ 和他关联的基本可行解 $x^*$ 选一个索引 $j \\notin B$ , 把 $x_j^*$ 从 $0$ 增大到 $\\theta \\ge 0$ 其他非底的变量应该不变, 为 $0$ 底中的变量应该自适应改动以维护约束成立 也就是说从 $x^\\ast$ 变成 $x^\\ast + \\theta \\cdot d$ Requirements for $d$ $d_j = 1$ (归一化) $d_{\\ell}=0, \\ell \\notin B, \\ell \\neq j$ $A\\left(x^*+\\theta d\\right)=b$ 必须满足, 因为移动后也必须是可行解, 所以我们可以推出 $A d=0$ Definition 26 ( $j$ -th basis direction)综上, $Ad = AB d_B+A{\\ast j}=0$ , $A_{\\ast j}$ 是约束矩阵 $A$ 的第 $j$ 列 $AB$ 的列是线性无关的, 所以 $A_B$ 是可逆的, 我们能直接推出 $d_B=-A_B^{-1} A{* j}$ $d_B$ 就是 $j$ -th basis direction Definition 27 (Reduced Cost)从 $x^\\ast$ 移动到 $x^\\ast+\\theta \\cdot d$ , 目标函数变化了 $\\theta \\cdot c^T d=\\theta\\left(cj-c_B^T A_B^{-1} A{\\ast j}\\right)$ 我们定义: $\\tilde{c}j=c_j-c_B^T A_B^{-1} A{\\ast j}$ 是 $x_j$ 的reduced cost. reduced cost是对每个 $j$ 都有定义的, 如果 $j \\in B$ , 那么 $x_j$ 的reduced cost就是0, 因为我们不能选这个 $j$ 作为进入变量, 所以无法改变目标函数 Matrix View中的 $c_N^T-c_B^T A_B^{-1} A_N$ 就是由 $j \\in N$ 的reduced cost构成 Min Ratio TestQ: What happens if the min ratio test fails to give us a value $θ$by which we can safely increase the entering variable? 我们知道 $\\theta = \\min \\left( \\max \\left( bi / A{i e}, 0 \\right) \\right)$ , 这里的 $A_{i e}$ 是第 $i$ 行中的在底中的变量的值 (具体看上面的步骤) 如果这些值中不是全是负的, 那么这个负值只会增大这个变量, 而不是减小, 所以是没有危险的 如果全是负的, 那么就没有离开变量选择了, LP就不是有界的了 Termination在Simplex方法的一次迭代中, 目标函数的值是不会下降的, 但是他会保证一直上升吗? 答案是: 并不! Definition 28 (退化 Degeneracy)一个基本可行解 $x^\\ast$ 是退化的, 如果集合 $J=\\left{j \\mid x_j^*&gt;0\\right}$ 满足 $|J|&lt;m$ 人话 若干个基本可行解重合了, 如图右下角有三个点重合了 总结: 如何挑选每次迭代中加入到底中的那个下标? 我们可以选择一列 $e$ 作为进入变量, 如果 $\\tilde{C}_e&gt;0$ ($\\tilde{c}_e$ 是 $x_e$ 对应的reduced cost) 标准选择是选 $\\tilde{c}_e$ 最大的那个列 $e$ 如果对所有 $i \\in{1, \\ldots, m}$ 都有 $A_{i e} \\leq 0$ , 那说明最大值是无界的 否则, 选一个离开变量 $l$ 使得 $b{\\ell} / A{\\ell e}$ 在所有的 $A_{i e}&gt;0$ 是最小的 如果有数个变量都同时是最小值, 那就到了一个退化的基本可行解 取决于 $l$ 的选取, Simplex方法可能会陷入死循环 一些感悟: 约束矩阵 $A$ 中的每一行都能代表一个在底中的变量, 而 $A$ 中的每一列代表一个变量, 因为 $A$ 是行满秩的 What do we have so far?Suppose we are given an initial feasible solution to an LP. If the LPis non-degenerate then Simplex will terminate.Note that we either terminate because the min-ratio test fails andwe can conclude that the LP is unbounded, or we terminatebecause the vector of reduced cost is non-positive. In the lattercase we have an optimum solution. Initial Solution TODO Lemma 29 (Optimality)有一个底 $B$ 和一个基于 $B$ 的基本可行解 $x^\\ast$ , $\\tilde{c} \\leq 0$ 能够得出 $x^\\ast$ 是LP的最优解 Definition 30 (Duality)主要线性规划(primal LP) $z=\\max \\left{c^T x \\mid A x \\leq b, x \\geq 0\\right}$ 的对偶问题(dual problem) 是 $w=\\min \\left{b^T y \\mid A^T y \\geq c, y \\geq 0\\right}$ Lemma 31一个主要线性规划问题的对偶问题的对偶问题是他自己 $\\begin{aligned} &amp; w=\\min \\left{b^T y \\mid A^T y \\geq c, y \\geq 0\\right} \\ &amp; w=-\\max \\left{-b^T y \\mid-A^T y \\leq-c, y \\geq 0\\right}\\end{aligned}$ $w$ 的对偶问题是: $\\begin{aligned} &amp; z=-\\min \\left{-c^T x \\mid-A x \\geq-b, x \\geq 0\\right} \\ &amp; z=\\max \\left{c^T x \\mid A x \\leq b, x \\geq 0\\right}\\end{aligned}$ Theorem 32 (Weak Duality)$z=\\max \\left{c^T x \\mid A x \\leq b, x \\geq 0\\right}$ 和 $w=\\min \\left{b^T y \\mid A^T y \\geq c, y \\geq 0\\right}$ 是一对对偶问题, $x$ 是主要可行(primal feasible), 当且仅当 $x \\in{x \\mid A x \\leq b, x \\geq 0}$ ,$y$ 是对偶可行(dual feasible), 当且仅当 $y \\in\\left{y \\mid A^T y \\geq c, y \\geq 0\\right}$ 给定 $\\hat{x}$ 是主要可行的, $\\hat{y}$ 是对偶可行的: c^T \\hat{x} \\leq z \\leq w \\leq b^T \\hat{y}查看证明 A^T \\hat{y} \\geq c \\Rightarrow \\hat{x}^T A^T \\hat{y} \\geq \\hat{x}^T c\\quad (\\hat{x} \\geq 0) A \\hat{x} \\leq b \\Rightarrow y^T A \\hat{x} \\leq \\hat{y}^T b \\quad (\\hat{y} \\geq 0)通过这两个能推出: c^T \\hat{x} \\leq \\hat{y}^T A \\hat{x} \\leq b^T \\hat{y}又因为 $z$ 是主要可行的最大解, $w$ 是对偶可行的最小解, 就有: $z \\leq w$ 另外: 如果主要线性规划问题 $P$ 是无界的, 那么其对偶问题 $D$ 就是不可行的 Simplex and Duality$z =\\max \\left{c^T x \\mid A x=b, x \\geq 0\\right} $ $w =\\min \\left{b^T y \\mid A^T y \\geq c\\right}$ 是一组对偶问题, 这也代表: 在解一个主要线性规划问题的对偶问题的时候, 我们没有变量非负的限制 查看证明 对主要线性规划问题进行改写: $\\begin{aligned} \\max &amp; \\left{c^T x \\mid A x=b, x \\geq 0\\right} \\\\ &amp; =\\max \\left{c^T x \\mid A x \\leq b,-A x \\leq-b, x \\geq 0\\right} \\\\ &amp; =\\max \\left{c^T x \\mid\\left[\\begin{array}{c}A \\\\ -A\\end{array}\\right] x \\leq\\left[\\begin{array}{c}b \\\\ -b\\end{array}\\right], x \\geq 0\\right}\\end{aligned}$ 这里的最后一步就是把两个不等式写成矩阵形式 改写后的对偶问题为: $\\begin{aligned} \\min &amp; \\left{\\left[b^T-b^T\\right] y \\mid\\left[A^T-A^T\\right] y \\geq c, y \\geq 0\\right} \\\\ &amp; =\\min \\left{\\left[b^T-b^T\\right] \\cdot\\left[\\begin{array}{c}y^{+} \\\\ y^{-}\\end{array}\\right] \\mid\\left[A^T-A^T\\right] \\cdot\\left[\\begin{array}{l}y^{+} \\\\ y^{-}\\end{array}\\right] \\geq c, y^{-} \\geq 0, y^{+} \\geq 0\\right} \\\\ &amp; =\\min \\left{b^T \\cdot\\left(y^{+}-y^{-}\\right) \\mid A^T \\cdot\\left(y^{+}-y^{-}\\right) \\geq c, y^{-} \\geq 0, y^{+} \\geq 0\\right} \\\\ &amp; =\\min \\left{b^T y^{\\prime} \\mid A^T y^{\\prime} \\geq c\\right}\\end{aligned}$ Proof of Optimality Criterion for Simplex假设我们有一个基本可行解 $x^\\ast$, 其reduced cost为: $\\tilde{c}=c^T-c_B^T A_B^{-1} A \\leq 0$ 这也代表 $x^ast$ 是最优解 (Lemma 29) 我们对这个式子进行改写: $A^T\\left(A_B^{-1}\\right)^T c_B \\geq c$ 令 $y^\\ast=\\left(A_B^{-1}\\right)^T c_B$ $\\begin{aligned} b^T y^\\ast &amp; =\\left(A x^\\ast\\right)^T y^\\ast=\\left(A_B x_B^\\ast\\right)^T y^\\ast \\\\ &amp; =\\left(A_B x_B^\\ast\\right)^T\\left(A_B^{-1}\\right)^T c_B=\\left(x_B^\\ast\\right)^T A_B^T\\left(A_B^{-1}\\right)^T c_B \\\\ &amp; =c^T x^\\ast\\end{aligned}$ 因为 $c^T \\hat{x} \\leq z \\leq w \\leq b^T \\hat{y}$ 所以 $y^\\ast$ 其实也是最优解 所以在 $x^\\ast$ 和 $y^\\ast$ 都是最优解的情况下, 对偶差距(Duality Gap)为 $0$ Strong Duality$P=\\max \\left{c^T x \\mid A x \\leq b, x \\geq 0\\right}$ $n_A$ : 变量的个数( $A$ 的列数), $m_A$ : 约束的个数 ( $A$ 的行数) 我们也可以把变量非负这个约束加入约束矩阵 $A$ ( $ x \\geq 0 \\Rightarrow -x \\leq 0$ ) 然后新的LP: $\\bar{P}=\\max \\left{c^T x \\mid \\bar{A} x \\leq \\bar{b}\\right}$ $n{\\bar{A}}=n_A, m{\\bar{A}}=m_A+n_A$ 新LP的对偶问题: $D=\\min \\left{\\bar{b}^T y \\mid \\bar{A}^T y=c, y \\geq 0\\right}$ Theorem 33 (Strong Duality)给定 $P$ 和 $D$ 互为对偶问题对, $z^\\ast$ 和 $w^\\ast$ 是这对问题的最优解, 那么: z^\\ast = w^\\astLemma 34 (Weierstrass)给定 $X$ 是一个凸集, $f(x)$ 是在凸集 $X$ 上的一个连续的函数, 那么 $\\min {f(x): x \\in X}$ 存在 Lemma 35 (Projection Lemma)给定 $X \\subseteq \\mathbb{R}^m$ 是一个非空的凸集, 并且 $y \\notin X$. 那就存在一个凸集上到 $y$ 的距离最近的点 $x^\\ast$ . 并且, 对所有 $x \\in X$ , 都有 $\\left(y-x^\\ast\\right)^T\\left(x-x^\\ast\\right) \\leq 0$ 查看证明 $f(x)=|y-x|$ 但是此时还不能用Lemma 34, 因为 $X$ 可能不是有界的 解决方法: 因为 $X \\neq \\varnothing$ , 所以存在一个点 $x’ \\in X$ , 定义 $X^{\\prime}=\\left{x \\in X \\mid|y-x| \\leq\\left|y-x^{\\prime}\\right|\\right}$ , 此时这个 $X’$ 就是闭合的(closed)并且有界的(bounded) 这样我们就可以通过Lemma 34证明: 最近点必定存在. 接下来证明 $\\left(y-x^\\ast\\right)^T\\left(x-x^\\ast\\right) \\leq 0$ 假设 $x^\\ast$ 是最近点. 所以 对所有的 $x \\in X$ , $\\left|y-x^\\ast\\right|^2 \\leq|y-x|^2$ 根据凸集的性质: $x \\in X$ 那么 对于所有的 $0 \\leq \\epsilon \\leq 1$ , $x^\\ast+\\epsilon\\left(x-x^\\ast\\right) \\in X$ ( $x$ 和 $x’$ 的连线上的点) \\begin{aligned} \\left\\|y-x^\\ast\\right\\|^2 & \\leq\\left\\|y-x^\\ast-\\epsilon\\left(x-x^\\ast\\right)\\right\\|^2 \\\\\\\\ & =\\left\\|y-x^\\ast\\right\\|^2+\\epsilon^2\\left\\|x-x^\\ast\\right\\|^2-2 \\epsilon\\left(y-x^\\ast\\right)^T\\left(x-x^\\ast\\right) \\end{aligned}改写一下上面的式子: $\\left(y-x^\\ast\\right)^T\\left(x-x^\\ast\\right) \\leq \\frac{1}{2} \\epsilon\\left|x-x^\\ast\\right|^2$ 如果 $\\epsilon \\rightarrow 0$ 就得到了我们要证明的结论 Theorem 36 (Separating Hyperplane)给定 $X \\subseteq \\mathbb{R}^m$ 是一个非空的凸集, 并且 $y \\notin X$. 那么一定存在一个分割超平面 $\\left{x \\in \\mathbb{R}: a^T x=\\alpha, a \\in \\mathbb{R}^m, \\alpha \\in \\mathbb{R} \\right}$ 将 $X$ 和 $y$ 分割开 (对于所有的 $x \\in X$, $a^T y&lt;\\alpha ; a^T x \\geq \\alpha$) 查看证明 $x^\\ast \\in X$ 是 $X$ 中距离 $y$ 的最近点 根据上面的定理, 对于所有的 $x \\in X$, $\\left(y-x^\\ast\\right)^T\\left(x-x^\\ast\\right) \\leq 0$ 令: $a=\\left(x^\\ast-y\\right)$ , $\\alpha=a^T x^\\ast$ 对于所有的 $x \\in X: a^T\\left(x-x^\\ast\\right) \\geq 0$ , 所以有 $a^T x \\geq \\alpha$ 同时 $a^T y=a^T\\left(x^\\ast-a\\right)=\\alpha-|a|^2&lt;\\alpha$ Lemma 37 (Farkas Lemma)给定 $A$ 是一个 $m \\times n$ 的矩阵, 那么下面两个陈述仅有一个是真的: $\\exists x \\in \\mathbb{R}^n$ , $A x=b, x \\geq 0$ $\\exists y \\in \\mathbb{R}^m$ , $A^T y \\geq 0, b^T y&lt;0$ 点击显/隐内容 首先我们先证明上述两个陈述最多有一个是正确的 假设 $\\hat{x}$ 满足第一天陈述, $\\hat{y}$ 满足第二条, 那么有 0>y^T b=y^T A x \\geq 0所以不能两条都同时满足 现在假设第一条不满足 $S={A x: x \\geq 0}$ 是矩阵 $A$ 的列的锥组合, 所以 $S$ 是闭合的, 凸的. 因为第一条不满足, 所以 $Ax \\neq b$ , 所以 $b \\notin S$ 我们想要证明存在一个 $y$ , 满足 $A^T y \\geq 0, b^T y&lt;0$ 让 $y$ 是分割 $b$ 和 $S$ 的半平面, 因此: $y^T b&lt;\\alpha$ 并且对于所有的 $s \\in S$ , $y^T s \\geq \\alpha$ $0 \\in S \\Rightarrow y^T \\cdot 0 \\geq \\alpha \\Rightarrow \\alpha \\leq 0 \\Rightarrow y^T b&lt;0$ 对于 $x \\geq 0$ , $y^T A x \\geq \\alpha$ , 因此 $y^T A \\geq 0$ (我们能随意指定 $x \\geq 0$ ) Lemma 38 (Farkas Lemma; different version)将两个陈述重写一下: $\\exists x \\in \\mathbb{R}^n$ , $[A \\quad I] \\cdot\\left[\\begin{array}{c}x \\\\ s\\end{array}\\right]=b, x \\geq 0, s \\geq 0$ $\\exists y \\in \\mathbb{R}^m$ , $\\left[\\begin{array}{c}A^T \\ I\\end{array}\\right] y \\geq 0, b^T y&lt;0$ Proof of Strong Duality讲了这么就的辅助定理, 正菜终于端上来了 $P: z=\\max \\left{c^T x \\mid A x \\leq b, x \\geq 0\\right} $ $D: w=\\min \\left{b^T y \\mid A^T y \\geq c, y \\geq 0\\right}$ Theorem 39 (Strong Duality) 同Theorem 33$\\boldsymbol{z} \\leq \\boldsymbol{w}$ : weak duality已经证明了 $z \\geq w$ : 我们证明 $z&lt;\\alpha$ 能够推出 $w&lt;\\alpha$ $\\begin{array}{rrcr} \\exists x \\in \\mathbb{R}^n &amp; \\\\ \\text { s.t. } &amp; A x &amp; \\leq &amp; b \\\\ &amp; -c^T x &amp; \\leq &amp; -\\alpha \\\\ &amp; x &amp; \\geq &amp; 0 \\end{array}$ $\\begin{array}{rrcr} \\exists y \\in \\mathbb{R}^m ; v \\in \\mathbb{R} &amp; \\\\ \\text { s.t. } &amp; A^T y-c v &amp; \\geq &amp; 0 \\\\ &amp; b^T y-\\alpha v &amp; &lt; &amp; 0 \\\\ &amp; y, v &amp; \\geq &amp; 0\\end{array}$ 因为我们这里假设的 $z&lt;\\alpha$ , 又因为 $z$ 是 $c^T x$ 的最大值, 所以 $c^T x$ 是不可能大于等于 $\\alpha$ 的, 所以左边的不等式组是不可能被满足的, 根据Farkas Lemma, 那么右边的一定是可满足的 如果解 $y, v$ 满足 $v=0$ , 那么我们就可以推出 \\begin{array}{rrcr}\\exists y \\in \\mathbb{R}^m & \\\\\\\\ \\text { s.t. } & A^T y & \\geq & 0 \\\\\\\\ & b^T y & < & 0 \\\\\\\\ & y & \\geq & 0\\end{array}是可满足的 这玩意儿的根据Farkars Lemma对应的那个不等式组其实就是原来的LP, 因此我们就推出原来的LP是不可能被满足的, 而我们假设LP应该是有解的, 所以 $v \\neq 0$ 必须满足 因此存在一个解 $y, v$ 满足 $v&gt;0$ 那么我们缩放整个不等式组 (同时缩放 $y$ 和 $v$), 让 $v=1$ \\begin{array}{rrcr} \\exists y \\in \\mathbb{R}^m ; v \\in \\mathbb{R} & \\\\\\\\ \\text { s.t. } & A^T y & \\geq & c \\\\\\\\ & b^T y & < & \\alpha \\\\\\\\ & y & \\geq & 0 \\\\\\\\ & v & = & 1\\end{array}因为这个不等式组是有解的, 因此存在 $y$ , $b^T y&lt;\\alpha$ , 因为 $w$ 是 $b^T y$ 的最小值, 所以有 $w&lt;\\alpha$ , 得证 所以怎么推出 $z \\geq w$ 来的 ? Lemma 41 (Complementary Slackness)假设LP $P=\\max \\left{c^T x \\mid A x \\leq b ; x \\geq 0\\right}$ 有解 $x^$ , 他的对偶问题 $D=\\min \\left{b^T y \\mid A^T y \\geq c ; y \\geq 0\\right}$ 有解 $y^$ , 那么: 如果 $x_j^*&gt;0$ 那么 $D$ 中第 $j$ 个约束是等号满足的 如果 $D$ 中第 $j$ 个约束不是等号满足的, 那么$x_j^*=0$ 如果 $y_i^*&gt;0$ 那么 $P$ 中第 $i$ 个约束是等号满足的 如果 $P$ 中第 $i$ 个约束不是等号满足的, 那么$x_i^*=0$ TODO: 写完这个 TODO: Interpretation of Dual Variables","link":"/2023/04/22/Effiziente-Algorithmen-und-Datenstrukturen-II/"},{"title":"P1113 杂物","text":"题目原文及输入/输出格式 题目描述John的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 1。John有需要完成的 n 个杂务的清单，并且这份清单是有一定顺序的，杂务 k(k&gt;1) 的准备工作只可能在杂务 1 至 k-1 中。 写一个程序从 1 到 n 读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定John的农场有足够多的工人来同时完成任意多项任务。 解法本题可以说是拓扑排序的模板题了。 因为计算每一个任务都需要把它的前置任务都计算一遍，所以很容易就想到拓扑排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt; #include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;climits&gt;using namespace std;struct edge{ int from, to; edge(int f, int t){ this-&gt;from=f; this-&gt;to=t; }}; vector&lt;edge&gt; G[10010]; //邻接表存图int n, A[10010], ans[10010], in[10010];queue&lt;int&gt; Q;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int a, b, temp; cin&gt;&gt;a&gt;&gt;b; A[i]=b; cin&gt;&gt;temp; while(temp!=0){ G[temp].push_back(edge(temp, a)); //建图 in[i]++; //计算入度 cin&gt;&gt;temp; } } //如果入度是0，即起点，插入队列中 for(int i=1;i&lt;=n;i++) if(in[i]==0){ ans[i]=A[i]; Q.push(i); } while(!Q.empty()){ int node=Q.front(); for(int i=0;i&lt;G[node].size();i++){ edge e=G[node][i]; in[e.to]--; //删除边 if(in[e.to]==0) Q.push(e.to); //入度被减为0，说明前驱都被计算过了，插入队列 ans[e.to]=max(ans[e.to], ans[node]+A[e.to]); //更新数据 } Q.pop(); } int aaa=0; for(int i=1;i&lt;=n;i++){ aaa=max(aaa, ans[i]); //统计数据 } cout&lt;&lt;aaa; return 0;}","link":"/2020/07/09/P1113-%E6%9D%82%E7%89%A9/"},{"title":"P1160 队列安排","text":"题目原文及输入/输出格式 题目描述一个学校里老师要将班上NN个同学排成一列，同学被编号为1∼N，他采取如下的方法： 先将1号同学安排进队列，这时队列中只有他一个人； 2~N号同学依次入列，编号为i的同学入列方式为：老师指定编号为i的同学站在编号为1~(i−1)中某位同学（即之前已经入列的同学）的左边或右边； 从队列中去掉M(M&lt;N)个同学，其他同学位置顺序不变。 在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。 思路根据题目描述可以看出本题需要多次对队列进行插入以及删除操作，自然联想到使用链表。 40分解法对于每个链表N内的元素node记录其上一个元素和下一个元素的下标和这个node代表的学生编号并使用cnt变量记录链表N内学生总数。每次更新总是在下标为cnt+1存入新的元素。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687struct node{ int last, next, id; node(int last, int next, int id){ this-&gt;id=id; this-&gt;next=next; this-&gt;last=last; } node(){} }N[100010];int n, m, cnt=0, head; void print(){ int temp=head; while(N[temp].next!=0){ cout&lt;&lt;N[temp].id&lt;&lt;&quot; &quot;; temp=N[temp].next; } cout&lt;&lt;N[temp].id;}int main(){ cin&gt;&gt;n; N[++cnt]=node(0, 0, 1); head=1; for(int i=2;i&lt;=n;i++){ int a,b,ans=-1; cin&gt;&gt;a&gt;&gt;b; int temp=head; while(N[temp].next!=0){ if(N[temp].id==a){ ans=temp; break; } temp=N[temp].next; } if(ans==-1) ans=temp; if(b==0){ node newN=node(N[ans].last, ans, i); N[++cnt]=newN; int t1=N[ans].last, t2=ans; N[t2].last=cnt; N[t1].next=cnt; if(ans==head) head=cnt; }else{ node newN=node(ans, N[ans].next, i); N[++cnt]=newN; int t1=ans, t2=N[ans].next; N[t2].last=cnt; N[t1].next=cnt; } } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int a, ans=-1; cin&gt;&gt;a; int temp=head; while(N[temp].next!=0){ if(N[temp].id==a){ ans=temp; break; } temp=N[temp].next; } if(ans==-1){ if(N[temp].id==a){ ans=temp; } } if(ans!=-1){ int t1=N[ans].last; int t2=N[ans].next; N[t1].next=N[ans].next; N[t2].last=N[ans].last; } } print(); return 0;} 反思每一次添加和删除都要遍历整个链表，每次遍历时间复杂度为$O(n)$，所以整个程序时间复杂度为$O(n^2)$。由于题目数据:对于100%的数据，有N, M≤100000(N,M≤100000)。所以必定TLE。 AC解法将学生编号作为下标，省去了cnt变量和每次插入和删除时的修改步骤，使每次遍历的时间复杂度为$O(1)$，程序时间复杂度降到$O(n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct node{ int last, next; node(int last, int next){ this-&gt;next=next; this-&gt;last=last; } node(){} }N[100010];int n, m, head, end; void print(){ int temp=head; while(temp!=end){ cout&lt;&lt;temp&lt;&lt;&quot; &quot;; temp=N[temp].next; } cout&lt;&lt;temp;}int main(){ cin&gt;&gt;n; head=1, end=1; N[head]=node(0, 0); for(int i=2;i&lt;=n;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; if(b==0){ node newN=node(N[a].last, a); N[i]=newN; int t1=N[a].last, t2=a; N[t2].last=i; N[t1].next=i; if(a==head) head=i; }else{ node newN=node(a, N[a].next); N[i]=newN; int t1=a, t2=N[a].next; N[t2].last=i; N[t1].next=i; if(a==end) end=i; } } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int a; cin&gt;&gt;a; if(N[a].last!=-1 &amp;&amp; N[a].next!=-1){ if(a==head) head=N[a].next; if(a==end) end=N[a].last; int t1=N[a].last; int t2=N[a].next; N[t1].next=N[a].next; N[t2].last=N[a].last; N[a].last=-1; N[a].next=-1; } } print(); return 0;}","link":"/2020/07/03/P1160-%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92/"},{"title":"Java学习笔记-多线程","text":"Java多线程详解 .post-summary { display: none; } Tipp：代码中的注释一定要看 基本概念：程序 进程 线程定义 程序（program）是为完成特定任务、用某种语言编写 的一 组指令的集合 。即指一段静态的代码，静态对象。 进程（process）是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 如运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程（thread）进程可进一步细化为线程，是一个程序内部的执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每一个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小 一个进程的多个线程共享相同的内存单元/内存地址空间—&gt;它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全隐患 线程与进程的关系 单核CPU和多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。但是CPU的时间单元特别短，因此感受不出来。 多核才能更好发挥多线程的效率。 一个Java的应用程序java.exe，其实至少有3个线程：main()主线程，gc()垃圾回收线程，异常处理线程。如果发生异常回影响到main()主线程。 并行与并发 并行：多个CPU同时执行多个任务。 并发：一个CPU（采用时间片）同时执行多个任务。 何时需要多线程 程序需要同时执行两个或者多个任务。 程序需要实现一些需要等待的任务，如用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序。 线程的创建和使用（重点）Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。 Thread类的特性： 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把urn()方法的主题称为线程体。 通过该Thread对象的start()方法来启动这个线程，而非直接调用run()。 多线程的创建方式方式一：继承Thread类1、创建一个继承Thread类的子类 2、重写Thread类的run()方法 3、创建Thread类的子类的对象 4、通过此对象调用start() 下面通过一个例子来演示方式一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package ThreadTest;/** * 多线程创建方式一：继承Thread类 * 1. 创建一个继承于Thread类的子类 * 2. 重写run()方法 --&gt;将此线程执行的操作声明在run()中 * 3. 创建子类的对象 * 4. 通过此对象调用start() * * 例子：遍历100以内所有的偶数 */public class ThreadCreate1 { public static void main(String[] args) { //3.创建子类的对象 MyThread myThread1 = new MyThread(); //4.通过此对象调用start() //作用 //1.启动当前线程 //2.JVM调用run()方法 myThread1.start(); //问题一：不能通过调用run()方法启动线程 //myThread.run(); //问题二：再启动一个线程，遍历100以内偶数不可以让已经start()的线程去执行。 //myThread.start(); //正确方式 MyThread myThread2 = new MyThread(); myThread2.start(); //以下循环仍然在main线程中运行 for (int i = 0; i &lt;= 100; i++) { //if(i % 2 == 1) System.out.println(&quot;main-&gt;&quot;+i); if(i % 2 == 0) System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i); } }}//1. 创建一个继承于Thread类的子类class MyThread extends Thread{ //2. 重写run()方法 @Override public void run() { for (int i = 0; i &lt;= 100; i++) { //if(i % 2 == 0) System.out.println(&quot;myThread-&gt;&quot;+i); if(i % 2 == 0) System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i); } }} 我的输出如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153Thread-3 : 0main : 0Thread-3 : 2Thread-4 : 0Thread-3 : 4main : 2Thread-4 : 2main : 4Thread-3 : 6Thread-4 : 4Thread-3 : 8main : 6Thread-3 : 10main : 8Thread-4 : 6Thread-3 : 12main : 10Thread-3 : 14Thread-4 : 8Thread-3 : 16main : 12Thread-3 : 18Thread-4 : 10Thread-3 : 20main : 14Thread-4 : 12Thread-3 : 22main : 16Thread-3 : 24Thread-4 : 14Thread-3 : 26Thread-3 : 28Thread-4 : 16Thread-3 : 30main : 18Thread-4 : 18Thread-3 : 32main : 20Thread-3 : 34main : 22Thread-4 : 20Thread-3 : 36main : 24Thread-4 : 22Thread-3 : 38main : 26Thread-4 : 24Thread-3 : 40main : 28Thread-4 : 26main : 30Thread-4 : 28main : 32Thread-3 : 42Thread-4 : 30main : 34Thread-3 : 44main : 36Thread-4 : 32Thread-3 : 46Thread-4 : 34main : 38Thread-3 : 48main : 40Thread-4 : 36Thread-3 : 50main : 42Thread-4 : 38Thread-3 : 52main : 44Thread-4 : 40main : 46Thread-4 : 42Thread-3 : 54Thread-4 : 44main : 48Thread-4 : 46main : 50Thread-4 : 48main : 52Thread-3 : 56Thread-4 : 50main : 54Thread-3 : 58main : 56Thread-4 : 52main : 58Thread-4 : 54main : 60Thread-3 : 60main : 62Thread-4 : 56Thread-3 : 62main : 64Thread-3 : 64main : 66Thread-4 : 58main : 68Thread-3 : 66Thread-4 : 60Thread-3 : 68main : 70Thread-4 : 62main : 72Thread-3 : 70main : 74Thread-4 : 64Thread-3 : 72main : 76Thread-3 : 74Thread-4 : 66main : 78Thread-3 : 76Thread-4 : 68Thread-3 : 78main : 80Thread-4 : 70main : 82Thread-3 : 80main : 84Thread-4 : 72main : 86Thread-3 : 82main : 88Thread-3 : 84main : 90Thread-4 : 74main : 92Thread-4 : 76main : 94Thread-4 : 78Thread-3 : 86main : 96Thread-3 : 88Thread-4 : 80Thread-3 : 90Thread-4 : 82Thread-3 : 92Thread-4 : 84Thread-3 : 94Thread-4 : 86main : 98Thread-3 : 96Thread-4 : 88Thread-3 : 98main : 100Thread-3 : 100Thread-4 : 90Thread-4 : 92Thread-4 : 94Thread-4 : 96Thread-4 : 98Thread-4 : 100 可见主线程和两个线程交替执行，多线程创建成功。 其余一些注意事项查看注释，以后不再赘述。 方式二：实现Runnable接口 创建一个实现Runnable接口的类 实现类去实现Runnable的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类对象 通过Thread类对象调用start() 演示代码： 1234567891011121314151617181920212223242526272829303132package ThreadTest;public class ThreadCreate2 { public static void main(String[] args) { //3.创建实现类的对象 MyThread5 m=new MyThread5(); //4.将此对象作为参数传递到Thread类的构造器中，创建Thread类对象 Thread thread = new Thread(m); //5.通过Thread类对象调用start() //作用 //1.启动线程 //2.调用当前线程的run()--&gt;调用了Runnable类型的target的run() thread.start(); Thread thread2 = new Thread(m); //被允许，因为新建了一个线程，只是共用了一份资源 thread2.start(); }}//1.创建一个实现Runnable接口的类class MyThread5 implements Runnable { //2.实现类去实现Runnable的抽象方法：run() @Override public void run() { for (int i = 0; i &lt;= 100; i++) { if(i % 2 == 0 ) System.out.println(i); } }} 两种线程创建方式的比较的结论开发中：优先选择实现Runnable接口的方式 原因： 实现方式没有类的单继承的局限性 实现的方式更适合处理多个线程有共享数据的情况 联系： Thread类本身也实现了Runnable接口 两种方式都需要重写run()，将线程要执行的逻辑声明再run()中。 Thread类的常用方法 void start()：启动当前线程 JVM调用当前线程的run()方法 void run()：通常需要重写Thread类中的此方法，将创建的线程需要执行的操作声明在此方法中 static Thread currentThread()：静态方法 返回当前代码执行的线程对象 String getName()：获取当前线程名字 void setName()：设置当前线程名字 static void yield()：释放当前cpu的执行权 void join()：在线程a中调用线程b.join()，此时线程a进入阻塞状态，直到线程b完全执行完毕 static void stop()：已过时。当执行此方法时，强制结束当前线程 void sleep(long ms)：让当前线程阻塞ms毫秒 boolean isAlive()：判断当前线程是否存活 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package ThreadTest;public class ThreadMethodTest { public static void main(String[] args) { MyThread3 m1=new MyThread3(&quot;我的Thread01&quot;); //m1.setName(&quot;线程一&quot;); m1.start(); //给主线程命名 Thread.currentThread().setName(&quot;主线程&quot;); for (int i = 0; i &lt;= 100; i++) { System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i); if(i == 20) { try { m1.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } System.out.println(m1.isAlive()); }}class MyThread3 extends Thread { public MyThread3(String name) { super(name); } @Override public void run() { for (int i = 0; i &lt;= 100; i++) { try { sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i); if(i % 20 == 0) yield(); } }} 我的输出如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203主线程 : 0主线程 : 1主线程 : 2主线程 : 3主线程 : 4主线程 : 5主线程 : 6主线程 : 7主线程 : 8主线程 : 9主线程 : 10主线程 : 11主线程 : 12主线程 : 13主线程 : 14主线程 : 15主线程 : 16主线程 : 17主线程 : 18主线程 : 19主线程 : 20我的Thread01 : 0我的Thread01 : 1我的Thread01 : 2我的Thread01 : 3我的Thread01 : 4我的Thread01 : 5我的Thread01 : 6我的Thread01 : 7我的Thread01 : 8我的Thread01 : 9我的Thread01 : 10我的Thread01 : 11我的Thread01 : 12我的Thread01 : 13我的Thread01 : 14我的Thread01 : 15我的Thread01 : 16我的Thread01 : 17我的Thread01 : 18我的Thread01 : 19我的Thread01 : 20我的Thread01 : 21我的Thread01 : 22我的Thread01 : 23我的Thread01 : 24我的Thread01 : 25我的Thread01 : 26我的Thread01 : 27我的Thread01 : 28我的Thread01 : 29我的Thread01 : 30我的Thread01 : 31我的Thread01 : 32我的Thread01 : 33我的Thread01 : 34我的Thread01 : 35我的Thread01 : 36我的Thread01 : 37我的Thread01 : 38我的Thread01 : 39我的Thread01 : 40我的Thread01 : 41我的Thread01 : 42我的Thread01 : 43我的Thread01 : 44我的Thread01 : 45我的Thread01 : 46我的Thread01 : 47我的Thread01 : 48我的Thread01 : 49我的Thread01 : 50我的Thread01 : 51我的Thread01 : 52我的Thread01 : 53我的Thread01 : 54我的Thread01 : 55我的Thread01 : 56我的Thread01 : 57我的Thread01 : 58我的Thread01 : 59我的Thread01 : 60我的Thread01 : 61我的Thread01 : 62我的Thread01 : 63我的Thread01 : 64我的Thread01 : 65我的Thread01 : 66我的Thread01 : 67我的Thread01 : 68我的Thread01 : 69我的Thread01 : 70我的Thread01 : 71我的Thread01 : 72我的Thread01 : 73我的Thread01 : 74我的Thread01 : 75我的Thread01 : 76我的Thread01 : 77我的Thread01 : 78我的Thread01 : 79我的Thread01 : 80我的Thread01 : 81我的Thread01 : 82我的Thread01 : 83我的Thread01 : 84我的Thread01 : 85我的Thread01 : 86我的Thread01 : 87我的Thread01 : 88我的Thread01 : 89我的Thread01 : 90我的Thread01 : 91我的Thread01 : 92我的Thread01 : 93我的Thread01 : 94我的Thread01 : 95我的Thread01 : 96我的Thread01 : 97我的Thread01 : 98我的Thread01 : 99我的Thread01 : 100主线程 : 21主线程 : 22主线程 : 23主线程 : 24主线程 : 25主线程 : 26主线程 : 27主线程 : 28主线程 : 29主线程 : 30主线程 : 31主线程 : 32主线程 : 33主线程 : 34主线程 : 35主线程 : 36主线程 : 37主线程 : 38主线程 : 39主线程 : 40主线程 : 41主线程 : 42主线程 : 43主线程 : 44主线程 : 45主线程 : 46主线程 : 47主线程 : 48主线程 : 49主线程 : 50主线程 : 51主线程 : 52主线程 : 53主线程 : 54主线程 : 55主线程 : 56主线程 : 57主线程 : 58主线程 : 59主线程 : 60主线程 : 61主线程 : 62主线程 : 63主线程 : 64主线程 : 65主线程 : 66主线程 : 67主线程 : 68主线程 : 69主线程 : 70主线程 : 71主线程 : 72主线程 : 73主线程 : 74主线程 : 75主线程 : 76主线程 : 77主线程 : 78主线程 : 79主线程 : 80主线程 : 81主线程 : 82主线程 : 83主线程 : 84主线程 : 85主线程 : 86主线程 : 87主线程 : 88主线程 : 89主线程 : 90主线程 : 91主线程 : 92主线程 : 93主线程 : 94主线程 : 95主线程 : 96主线程 : 97主线程 : 98主线程 : 99主线程 : 100false 线程的调度调度策略1.时间片 2.抢占式：高优先级的线程抢占CPU Java的调度方法同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级等级MAX_PRIORITY=10 MIN_PRIORITY=1 NORM_PRIORITY=5（默认） 涉及的方法int getPriority()：返回线程优先级 void setPriority(int newPriority)：改变线程的优先级 小提示线程创建时继承父线程的优先级。 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。 补充：线程的分类Java的线程中分为两类：一种是用户线程，一种是守护线程。 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 守护线程是用来服务用户线程的，通过在start()方法调用前调用(thread).setDaemon(true)可以把一个用户线程变成一个守护线程。 Java垃圾回收就是一个典型的守护线程。 若JVM中都是守护线程，当前JVM将退出。 （演示代码待补充） https://blog.csdn.net/qq_41063141/article/details/91939540 线程的生命周期JDK中用了Thread.State类定义了线程的六种状态： NEW：A Thread which has not yet started. RUNNABLE：A Thread which is running or suspended. BLOCKED：A Thread which is blocked on a monitor. WAITING：A Thread which is waiting with no timeout. TIMED_WAITING：A Thread which is waiting with a timeout. TERMINATED：A thread which is no longer alive. 这种分类是按照方法分的，不是很清晰，可以按照线程的状态分成5种状态： 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件 ，只是没分配到CPU资源。 运行：当就绪的线程被调度并获得CPU资源时便进入运行状态，run()方法定义了线程的操作和功能。 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态。 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。 线程的同步线程的安全问题多个线程执行的不确定性会引起执行结果的不确定性。 多个线程对数据的共享，会造成操作的不完整性，会破坏数据。 原因当多条语句在操作同一个线程共享数据时，一个线程对多条语句执行了一部分，还没有执行完，另一个线程参与进来执行，导致共享数据的错误。 解决方法对多条操作共享数据的语句，只能让一个线程都执行完，在执行的过程中，其他线程不能参与执行。 使用Synchronized关键字实现线程的同步同步代码块12345synchronized(同步监视器){ //需要同步的代码} 说明： 操作共享数据的代码就是需要被同步的代码。 共享数据是多个线程共同操控的变量。 同步监视器俗称“锁”。任何一个类的都可以充当“锁”。 多个线程必须共用同一把锁，即同步监视器必须是同一个对象。 实现Runnable接口创建的线程可以考虑使用this充当同步监视器，继承Thread类创建的线程慎用this。 继承Thread类创建的线程可以考虑使用(类名).class充当同步监视器。 同步方法1234567//格式：//访问修饰符 synchronized 返回值类型 方法名(){}//例子public synchronized void musterMethod(){ //方法体} 说明： 同步方法仍然涉及到同步监视器，只不过不需要显式声明。 非静态的同步方法的同步监视器为this，静态的同步方法的同步监视器是(类名).class。 同步的优点与局限优点：解决了线程的安全问题 局限：操作同步时只能由一个线程参与，其他线程等待，相当于一个单线程的过程，效率较低。 死锁问题不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。 解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 死锁样例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package ThreadTest;class A { public synchronized void foo(B b) { System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 进入了A实例的foo方法&quot;); // ① try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 企图调用B实例的last方法&quot;); // ③ b.last(); } public synchronized void last() { System.out.println(&quot;进入了A类的last方法内部&quot;); }}class B { public synchronized void bar(A a) { System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 进入了B实例的bar方法&quot;); // ② try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 企图调用A实例的last方法&quot;); // ④ a.last(); } public synchronized void last() { System.out.println(&quot;进入了B类的last方法内部&quot;); }}public class DeadLock implements Runnable { A a = new A(); B b = new B(); public void init() { Thread.currentThread().setName(&quot;主线程&quot;); // 调用a对象的foo方法 a.foo(b); System.out.println(&quot;进入了主线程之后&quot;); } public void run() { Thread.currentThread().setName(&quot;副线程&quot;); // 调用b对象的bar方法 b.bar(a); System.out.println(&quot;进入了副线程之后&quot;); } public static void main(String[] args) { DeadLock dl = new DeadLock(); new Thread(dl).start(); dl.init(); }} 我的输出 1234当前线程名: 主线程 进入了A实例的foo方法当前线程名: 副线程 进入了B实例的bar方法当前线程名: 主线程 企图调用B实例的last方法当前线程名: 副线程 企图调用A实例的last方法 然后程序就没了动静，也没结束，这就是死锁。 主线程想要B实例这把锁，副线程想要A实例这把锁，争执不下，都进入阻塞状态。 使用Lock的实现类实现线程的同步从JDK 5.0开始Java提供了更强大的线程同步机制：通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。 演示代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package Lock;import java.util.concurrent.locks.ReentrantLock;class myThread implements Runnable{ //共享资源 private int resource=10; //1.生成一把“锁” ReentrantLock lock=new ReentrantLock(false); @Override public void run() { try{ while(true){ //2.操作共享数据之前先上锁 lock.lock(); if(resource&gt;0){ System.out.println(Thread.currentThread().getName()+&quot; 抢到第&quot;+(11-resource)+&quot;份资源&quot;); resource--; }else break; //3.操作完成，解锁 lock.unlock(); try { //休眠，增加交互概率 Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }finally{ //4.万一循环被break或者try内语句出现异常，最后给线程解锁 lock.unlock(); } }}public class LockTest { public static void main(String[] args) { myThread m=new myThread(); Thread t1=new Thread(m); Thread t2=new Thread(m); Thread t3=new Thread(m); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t3.setName(&quot;线程3&quot;); t1.start(); t2.start(); t3.start(); }} 说明：和synchronized一样，多个线程处理共享资源的时候应当共用同一个Lock对象。 Lock和synchronized的比较 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放。 Lock只有代码块锁，synchronized有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）。 优先使用顺序：Lock—&gt;同步代码块（已经进入了方法体，分配了相应资源）—&gt;同步方法（在方法体之外） 线程的通信synchronized的通信方式wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。 说明： 在当前线程中调用方法：对象名.wait()。 使当前线程进入等待（某对象）状态，直到另一线程对该对象发出notify()或notifyAll()为止。 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）。 调用此方法后，当前线程将释放对象监控权，然后进入等待。 在当前线程被notify()后，要重新获得监控权，然后从断点处继续代码的执行。 notify()：唤醒正在排队等待同步资源的线程中优先级最高者，让其结束等待。 notifyAll()：唤醒正在排队等待资源的所有线程，让它们结束等待。 说明： 在当前线程中调用方法：对象名.notify()/notifyAll()。 功能：唤醒等待该对象监控权的一个/所有线程。 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）。 总结这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。 因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。 演示代码让两个线程交替输出1-10的数 1234567891011121314151617181920212223242526272829303132333435363738394041//实现Runnable接口创建线程package CommunicateTest;public class Test1 { public static void main(String[] args) { myThread m = new myThread(); Thread myThread1 = new Thread(m); Thread myThread2 = new Thread(m); myThread1.setName(&quot;我的线程1&quot;); myThread2.setName(&quot;我的线程2&quot;); myThread1.start(); myThread2.start(); }}class myThread implements Runnable{ private static int num=1; @Override public void run() { while (true) { synchronized (this) { notify(); if (num &lt;= 10) { System.out.println(Thread.currentThread().getName() + &quot;：输出&quot; + num); num++; try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else break; } } }} 123456789101112131415161718192021222324252627282930313233343536373839404142//继承Thread类方法创建线程package CommunicateTest;public class Test2 { public static void main(String[] args) { myThread2 m1 = new myThread2(); myThread2 m2 = new myThread2(); m1.setName(&quot;我的线程1&quot;); m2.setName(&quot;我的线程2&quot;); m1.start(); m2.start(); }}class myThread2 extends Thread{ private static int num=1; @Override public void run() { while (true) { synchronized (myThread2.class) { myThread2.class.notify(); if (num &lt;= 10) { System.out.println(Thread.currentThread().getName() + &quot;：输出&quot; + num); num++; try { myThread2.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else break; } } }} 经典例题：生产者消费者问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package ProductorCustomerTest;public class Test { public static void main(String[] args) { Clerk clerk = new Clerk(); Productor p1 = new Productor(clerk); p1.setName(&quot;生产者1&quot;); Customer c1 = new Customer(clerk); c1.setName(&quot;消费者1&quot;); p1.start(); c1.start(); }}class Clerk{ private int productionNum; public Clerk(){ this.productionNum=0; } public synchronized void addProduction() { if(productionNum&lt;20){ productionNum++; System.out.println(Thread.currentThread().getName()+&quot;：生产第&quot;+productionNum+&quot;个产品&quot;); notify(); }else{ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void getProduct() { if(productionNum&gt;0){ System.out.println(Thread.currentThread().getName()+&quot;：消费第&quot;+productionNum+&quot;个产品&quot;); productionNum--; notify(); }else{ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Productor extends Thread{ Clerk clerk; public Productor(Clerk c){ this.clerk=c; } @Override public void run() { System.out.println(getName()+&quot;开始生产！&quot;); while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.addProduction(); } }}class Customer extends Thread{ Clerk clerk; public Customer(Clerk c){ this.clerk=c; } @Override public void run() { System.out.println(getName()+&quot;开始消费！&quot;); while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.getProduct(); } }} JDK 5.0新增的线程创建方式实现Callable接口与使用Runnable相比，Callable功能更加强大 相比run()方法，可以有返回值 方法可以抛出异常 返回值支持泛型 需要借助FutureTask类，比如获取返回结果 Future接口可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。 FutrueTask是Future接口的唯一实现类。 FutureTask同时实现了Runnable、Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 演示代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package ThreadCallable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @author 11346 */public class Test { public static void main(String[] args) { //3.创建Callable接口实现类的对象 NumThread numThread = new NumThread(); //4.将此Callable实现类对象传入FutureTask的构造器中，创建FutureTask的对象 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(numThread); //5.将FutureTask的对象作为参数传入Thread类的构造器中，创建Thread类的对象，并start() new Thread(futureTask).start(); try { //6.需要的话获取返回值 //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值 Integer integer = futureTask.get(); System.out.println(&quot;返回值为：&quot; + integer); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }}//1.创建一个实现Callable接口的实现类class NumThread implements Callable&lt;Integer&gt;{ //2.实现call()，将此线程需要执行的方法声明在call()中 @Override public Integer call() throws Exception { int sum=0; for(int i=0;i&lt;=100;i++){ if((i &amp; 1) == 0){ System.out.println(Thread.currentThread().getName()+&quot;：&quot;+i); sum+=i; } } return sum; }} 线程池背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理： corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 … 线程池相关APIJDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command)：执行任务命令，没有返回值，一般用来执行Runnable。 Future submit(Callable task)：执行任务，有返回值，一般用来执行Callable。 void shutdown()：关闭连接池。 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池。 Executors.newFixedThreadPool(int n)：创建一个可重用固定线程数的线程池。 Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池。 Executors.newScheduledThreadPool(int n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package ThreadPool;import java.util.concurrent.*;public class Test { public static void main(String[] args) { //1.提供指定数量的线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); //设置属性得用实现类，接口里面没有设置属性的方法 ThreadPoolExecutor executor = (ThreadPoolExecutor) executorService; //设置属性 executor.setMaximumPoolSize(15); //2.执行指定的线程的操作。需要提供实现Runnable或者Callable接口的实现类的对象 executor.execute(new EvenNumThread()); //适合使用于Runnable FutureTask&lt;Integer&gt; futureTask = (FutureTask&lt;Integer&gt;) executor.submit(new OddNumThread());//适合使用于Callable try { Integer integer = futureTask.get(); System.out.println(&quot;返回值为：&quot;+integer); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } //3.关闭连接池 executorService.shutdown(); }}class EvenNumThread implements Runnable{ @Override public void run() { for(int i=0;i&lt;=100;i++){ if((i &amp; 1) == 0) System.out.println(Thread.currentThread().getName()+&quot;：&quot;+i); } }}class OddNumThread implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum=0; for(int i=0;i&lt;=100;i++){ if((i &amp; 1) != 0){ System.out.println(Thread.currentThread().getName()+&quot;：&quot;+i); sum+=i; } } return sum; }} 更新日志 2020.08.17 更新基本概念：程序 进程 线程中的定义和线程与进程的关系。 2020.08.20 更新基本概念：程序 进程 线程中的单核CPU和多核CPU的理解、并行与并发的辨析和何时需要多线程。第一节更新完毕。 2020.09.05 开始更新线程的创建和使用（重点） 2020.09.06 继续更新线程的创建和使用（重点），完成了方式一的代码和输出。完成Thread类的常用方法。 2020.09.07 继续更新线程的创建和使用（重点），完成了线程的调度，线程的创建方式二：实现Runnable接口。 2020.09.09 更新线程的创建和使用（重点）中的线程的分类和线程的生命周期。 2020.09.10 开始更新线程的同步。 2020.09.11 更新线程的同步中的死锁问题和显式锁Lock。 2020.09.12 更新线程的通信。 2020.09.19 更新JDK 5.0新增的线程创建方式。","link":"/2020/08/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"P1807 最长路","text":"题目原文及输入/输出格式 题目描述设$G$为有$n$个顶点的带权有向无环图，$G$中各顶点的编号为$1$到$n$，请设计算法，计算图$G$中 $$间的最长路径。 拓扑排序解法因为是有向无环图DAG，所以可以用拓扑排序计算路径。 因为是要计算的最长路，所以要引入一个bj数组，只更新1号点能够到达的点的路径长度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt; #include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;climits&gt;using namespace std;struct edge{ int to, weight; edge(int t, int w){ this-&gt;to=t; this-&gt;weight=w; }}; vector&lt;edge&gt; G[50010]; //邻接表存图int n, m, ans[1510], inDeg[1510], bj[1510];queue&lt;int&gt; Q;int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int a, b, c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; inDeg[b]++; //计算入度 G[a].push_back(edge(b, c)); } for(int i=1;i&lt;=n;i++){ if(inDeg[i]==0) Q.push(i); //将入度为0的点插入队列 } bj[1]=1; //标记1号点 while(!Q.empty()){ int f=Q.front(); for(int i=0;i&lt;G[f].size();i++){ edge e=G[f][i]; inDeg[e.to]--; if(bj[f]==1){ //只有起点是1号点或者是1号点能到的点才更新数据 ans[e.to]=max(ans[e.to], ans[f]+e.weight); //更新数据 bj[e.to]=1; //把这个点也标记成1号点能到的点 } if(inDeg[e.to]==0){ //入度被减为0，插入队列 Q.push(e.to); } } Q.pop(); } int aaa=ans[n]; //计算答案 if(aaa!=0) cout&lt;&lt;aaa; else cout&lt;&lt;-1; return 0;} 更多解法to be continued…","link":"/2020/07/09/P1807-%E6%9C%80%E9%95%BF%E8%B7%AF/"},{"title":"P4387 验证栈序列","text":"题目原文及输入/输出格式 题目描述给出两个序列 pushed 和 poped 两个序列，其取值从 1 到 n(n&lt;100000)。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 Yes，否则输出 No。 AC解法本题原理不清，解法思路来自洛谷题解。 1234567891011121314151617181920212223242526int p, n, A[100010], B[100010];stack&lt;int&gt; S; int main(){ cin&gt;&gt;p; for(int k=1;k&lt;=p;k++){ cin&gt;&gt;n; int sum=1; for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;B[i]; //输入 for(int i=1;i&lt;=n;i++){ S.push(A[i]); //按顺序入栈 while(S.top()==B[sum]){ //如果栈顶和出栈序列头相同就弹出，可能连续弹出 S.pop(); sum++; if(S.empty()) break; //防栈空 } } if(S.empty()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; while(!S.empty()) S.pop(); //清理栈 } return 0;}","link":"/2020/07/03/P4387-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/"},{"title":"P2058 海港","text":"题目原文及输入/输出格式 题目描述小K是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。 小K对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第$i$艘到达的船，他记录了这艘船到达的时间$ti$ (单位：秒)，船上的乘 客数$k_i$，以及每名乘客的国籍 $x{i,1}, x{i,2},…,x{i,k}$。 小K统计了$n$艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的24小时(24小时=86400秒）内所有乘船到达的乘客来自多少个不同的国家。 形式化地讲，你需要计算$n$条信息。对于输出的第$i$条信息，你需要统计满足$ti-86400&lt;t_p&lt;t_i$的船只$p$，在所有的$x{p,j}$中，总共有多少个不同的数。 思路将所有航班的船只信息（到达时间和人）储存下来，而后对所有船只进行遍历，每次寻找该次遍历下船只到达时间24小时内的其他到达海港的船只，最后清点国籍计算答案。 70分代码完全按照思路来模拟，用vector存储所有的人，保存在结构体内，最后计算答案。清点国籍的部分用Hash Map。 123456789101112131415161718192021222324252627282930313233struct ship{ int time; vector&lt;int&gt; people;}S[100010]; int n;map&lt;int, int&gt; check;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int t, num; cin&gt;&gt;t&gt;&gt;num; S[i].time=t; for(int j=1;j&lt;=num;j++){ int temp; cin&gt;&gt;temp; S[i].people.push_back(temp); } } for(int i=1;i&lt;=n;i++){ check.clear(); int ans=0; for(int j=i;S[i].time-S[j].time&lt;86400 &amp;&amp; j&gt;0;j--){ for(int k=0;k&lt;S[j].people.size();k++){ if(check[S[j].people[k]]==0) ans++; check[S[j].people[k]]=check[S[j].people[k]]+1; } } cout&lt;&lt;ans&lt;&lt;endl; } return 0;} 优化70分肯定是不满足的，我们还有进行一(亿)点优化。首先有几个问题需要思考：是存船只的数据好还是只存人的数据，然后把船只的到达时间作为人的属性存储好？还有就是是不是每个人的数据都要存下来？第二个问题的答案很明确，显然不是每个人的数据都必须存下来，本题中只需要某次航班24小时内的船只信息，所以人数据的删除和添加是比较多的，所以第一个问题我认为是储存人的数据更好。所以做出以下改动： 取消船只的结构体，进而改成人的数据。 使用队列，每次遍历某个航班时，先搜查队列信息，将24小时之后的信息全部删除，然后再统计本次航班数据。 由2可知，某次航班的答案必定和上一班的答案有关系，因为这一班的答案是通过上一班的答案的删除和新增得来的。 AC代码结构体person存人的信息，让入队列P中。最后遍历中对之前24小时之外的航班和本次航班的国籍统计还是使用Hash Map。 12345678910111213141516171819202122232425262728293031323334353637383940struct person{ int time, nation; person(int t, int n){ this-&gt;time=t; this-&gt;nation=n; }};int n, ans;map&lt;int, int&gt; check;queue&lt;person&gt; P;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int time, num; cin&gt;&gt;time&gt;&gt;num; while(!P.empty()){ person p=P.front(); if(p.time+86400 &lt;= time){ check[p.nation]--; if(check[p.nation]==0) ans--; P.pop(); }else break; } for(int j=1;j&lt;=num;j++){ int a; cin&gt;&gt;a; if(check[a]==0) ans++; check[a]++; P.push(person(time, a)); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2020/07/03/P2058-%E6%B5%B7%E6%B8%AF/"},{"title":"P2234 营业额统计","text":"题目原文及输入/输出格式 题目描述Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 当最小波动值越大时，就说明营业情况越不稳定。 而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。 该天的最小波动值=min{|该天以前某一天的营业额-该天营业额|}。 20分解法——纯模拟根据题目提供的公式：该天的最小波动值=min{|该天以前某一天的营业额-该天营业额|}，遍历该天之前的营业额求最小波动值。 每一次遍历求解的时间复杂度是$O(n)$，程序时间复杂度是$O(n^2)$ 123456789101112131415161718192021long long n, U[32780];long long ans;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;U[i]; for(int i=1;i&lt;=n;i++){ if(i==1){ ans+=U[i]; continue; } long long minn=LLONG_MAX; for(int j=i-1;j&gt;=1;j--){ minn=min(minn, abs(U[i]-U[j])); } ans+=minn; } cout&lt;&lt;ans; return 0;} 优化解法to be continued","link":"/2020/07/05/P2234-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1/"},{"title":"P5076 普通二叉树（简化版）","text":"题目原文及输入/输出格式 题目描述您需要写一种数据结构，来维护一些数（ 都是$10^9$以内的数字）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数$q$不超过$10^4$： 查询$x$数的排名（排名定义为比当前数小的数的个数+1。若有多个相同的数，因输出最小的排名）。 查询排名为$x$的数。 求$x$的前驱（前驱定义为小于$x$，且最大的数）。若未找到则输出-2147483647。 求$x$的后继（后继定义为大于$x$，且最小的数）。若未找到则输出 2147483647。 插入一个数$x$。 AC解法模板题就不多说直接上代码。关于BST可以看我另一篇专门的文章。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120struct tree{ int left, right, val, size, cnt;}T[10010];int sum, n;void add(int x, int v){ T[x].size++; if(T[x].val==v){ T[x].cnt++; return; } if(v&lt;T[x].val){ if(T[x].left!=0) add(T[x].left, v); else{ T[x].left=++sum; T[sum].cnt=1; T[sum].size=1; T[sum].val=v; } }else{ if(T[x].right!=0) add(T[x].right, v); else{ T[x].right=++sum; T[sum].cnt=1; T[sum].size=1; T[sum].val=v; } }} int querypre(int x, int val, int ans){ if(T[x].val&gt;=val){ if(T[x].left==0) return ans; else querypre(T[x].left, val, ans); }else{ if(T[x].right==0) return T[x].val; if(T[x].cnt==0) return querypre(T[x].right, val, ans); else return querypre(T[x].right, val, T[x].val); }}int querynext(int x, int val, int ans){ if(T[x].val&lt;=val){ if(T[x].right==0) return ans; else querynext(T[x].right, val, ans); }else{ if(T[x].left==0) return T[x].val; if(T[x].cnt==0) return querynext(T[x].left, val, ans); else return querynext(T[x].left, val, T[x].val); }}int queryrankfromval(int x, int val){ if(x==0) return 0; if(T[x].val==val) return T[T[x].left].size+1; else if(T[x].val&gt;val) return queryrankfromval(T[x].left, val); else return queryrankfromval(T[x].right, val)+T[x].cnt+T[T[x].left].size;}int queryvalfromrank(int x, int rank){ if(T[T[x].left].size&gt;=rank) return queryvalfromrank(T[x].left, rank); else if(T[T[x].left].size+T[x].cnt&gt;=rank) return T[x].val; else return queryvalfromrank(T[x].right, rank-T[T[x].left].size-T[x].cnt);}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int a, b; cin&gt;&gt;a&gt;&gt;b; switch(a){ case 1:{ cout&lt;&lt;queryrankfromval(1, b)+1&lt;&lt;endl; break; } case 2:{ cout&lt;&lt;queryvalfromrank(1, b)&lt;&lt;endl; break; } case 3:{ cout&lt;&lt;querypre(1, b, -2147483647)&lt;&lt;endl; break; } case 4:{ cout&lt;&lt;querynext(1, b, 2147483647)&lt;&lt;endl; break; } case 5:{ if(i==1){ T[i].val=b; T[i].cnt++; T[i].size++; sum++; }else add(1, b); break; } } } return 0;}","link":"/2020/07/05/P5076-%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89/"},{"title":"Unity Shader (1. 数学基础)","text":"","link":"/2023/03/29/Unity-Shader-1-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"title":"WSL 折腾记录","text":"之前报了一个GAMES 106的网络公开课，讲渲染管线的，说是windows，mac和linux都能build，但是windows属实不太适合写代码（搞了半天搞出一堆bug、缺依赖库，属实难蚌）。但是想用linux但是在VM里面不是很好去使用GPU，正巧搜的时候看到最新的WSL2用的其实是windows的GPU，所以就小小的折腾了一下。 本次安装的linux发行版是Ubuntu 20.04.05。 .post-summary { display: none; } WSL的安装如果想默认安装的话（直接装在C盘），直接按照官方的安装步骤走下去就好了。但是我C盘一般是不安装软件的，只存放系统相关的文件，这样重装系统就不需要再安装软件了。所以安装步骤上有一点小小的额外步骤。 安装前的准备先按照官方的安装步骤初始化WSL。可以下载（他下载之后不是直接安装的），但是不要安装系统！！！ 在Microsoft Store下载Ubuntu WSL版本直接在Microsoft Store上面搜索Ubuntu，会出来几个版本： Ubuntu：Ubuntu最新的发行版 Ubuntu 20.04.05：Ubuntu 20.04.05的发行版，我们下的就是这个 其他：其他的Ubuntu发行版版本 这个时候我们就可以点进去安装。 下好之后千万别启动！！！ 将下载好的Ubuntu“偷出来”使用微软商店下载的应用安装包会默认保存在C:\\Program Files\\WindowsApps目录下，但是这个目录是很难通过GUI去访问的，所以我们通过命令行。 先用管理员cd进这个目录: 12# powershell / cmdcd &quot;C:\\Program Files\\WindowsApps&quot; 然后查看当前目录下的内容： 12# Ubuntu一般是安装在CanonicalGroupLimited开头的文件夹里面dir CanonicalGroupLimited* 说明我们要找的安装包就在这四个目录下面，依次用dir命令查看里面的内容。看到一个文件叫“ubuntu2004.exe”就说明找到了。我这运气不太好，是在最后一个目录下才找到的。 找到之后就可以直接cp到你想要放置WSL的地方了 1cp &lt;安装包所在的文件夹名&gt;\\* &lt;你想要安装ubuntu文件夹的路径&gt; cp出来之后其实就可以直接卸载微软商城里的Ubuntu了。（什么卸磨杀驴） Ubuntu 20.04.5的安装直接双击打开“ubuntu2004.exe”就好了。 装好之后需要设置一下用户名密码。 升级一下软件（可选）我是习惯进了系统之后先把软件升级一下的。 12sudo apt updatesudo apt upgrade 然后就等待他安装完成。 开启ssh服务不知道为啥，WSL默认装的sshd没法ssh连接，因此我们需要重装一下。 12345# 删掉原先的ssh serversudo apt-get remove openssh-server# 重新安装ssh serversudo apt-get install openssh-server 我们还要改一下sshd_config里面的一些设置来打开密码登录和免密登录。 1sudo vi /etc/ssh/sshd_config PubkeyAuthentication yes：去掉前面的#来允许免密登录 PasswordAuthentication no：把no改成yes来允许密码登录 12# 重启一下ssh服务sudo service ssh restart 动态IP登录登录WSL需要一个IP，我们要用ifconfig就得先装这个包： 1sudo apt install net-tools 然后就可以查看IP了 1ifconfig 静态IP登录这一块是引用别人的代码（源地址我忘记了，但是网上很多用的都是同一个原理）。 保存为.bat文件之后，用这个bat直接在windows打开WSL并且分配固定IP，记得用管理员运行，或者直接加入开机启动项。 12345678910111213141516171819202122232425@echo offsetlocal enabledelayedexpansionREM 顺便开启sshwsl -d Ubuntu-20.04 -u root service ssh start:: set wsl2 ipwsl -d Ubuntu-20.04 -u root ip addr | findstr &quot;172.17.156.13&quot; &gt; nulif !errorlevel! equ 0 ( echo wsl ip has set) else ( wsl -d Ubuntu-20.04 -u root ip addr add 172.17.156.13/28 broadcast 172.17.156.15 dev eth0 label eth0:1 echo set wsl ip success: 172.17.156.13):: set windows ipipconfig | findstr &quot;172.17.156.1&quot; &gt; nulif !errorlevel! equ 0 ( echo windows ip has set) else ( netsh interface ip add address &quot;vEthernet (WSL)&quot; 172.17.156.1 255.255.255.240 echo set windows ip success: 172.17.156.1)pause WSL下的图形化界面X11 Forwarding这个就是和其他linux远程访问一样的设置。 WSGL微软不太推荐我们给WSL安装桌面环境，但是还是提供了图形化的支持：WSLG。这个是直接集成在最新的WSL里面的，所以不需要额外的安装。想要测试的话可以安装x11-apps这个库，然后启动xclock。 X11和WSLG是不能一起用的。 测试12sudo apt install x11-appsxclock 正常情况下都会有一个小小的时钟界面出现： （不用X11 Forwarding还是很舒服的） 免密登录和普通linux是一样的，把本地的公钥传到~/.ssh/authorized_keys这个文件里就可以了。 安装喜欢的shell这一步可以查看我的这篇博客，步骤都是一样一样的。 Vscode微软很贴心地为我们提供了一个拓展包：Remote Development。这个包里面有一个Remote: WSL的拓展。 如果用WSLG作为图形界面的话需要在设置里面把Remote X11.WSL这个选项勾掉（不选中），反之X11的话就勾上。设置完记得重启一下。","link":"/2023/04/07/WSL-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"},{"title":"主题使用技巧","text":"我现在使用的主题是从Icarus主题魔改过来的 这篇文章侧重使用主题的技巧 .post-summary { display: none; } 使用Bulma美化文章转载自这里 按钮 Info Success Warning Danger 点击展开代码 >folded123456&lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;button is-info&quot;&gt;Info&lt;/button&gt; &lt;button class=&quot;button is-success&quot;&gt;Success&lt;/button&gt; &lt;button class=&quot;button is-warning&quot;&gt;Warning&lt;/button&gt; &lt;button class=&quot;button is-danger&quot;&gt;Danger&lt;/button&gt;&lt;/div&gt; 光有按钮肯定是不行的，一般我们还需要给按钮增加事件，比如点击下面的按钮，可以显示一条一言（Hitokoto）。 显示一言 ↑↑↑ 试着点击“显示一言”！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } 点击展开代码 >folded12345678910111213141516&lt;button class=&quot;button is-info&quot; onclick=&quot;showHitokoto(event)&quot;&gt;显示一言&lt;/button&gt;&lt;blockquote class=&quot;hitokoto&quot;&gt;↑↑↑ 试着点击“显示一言”！&lt;/blockquote&gt;&lt;script&gt;function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } });}&lt;/script&gt; 进度条 点击展开代码 >folded12345&lt;progress class=&quot;progress is-info&quot; value=&quot;20&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-success&quot; value=&quot;40&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-warning&quot; value=&quot;60&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-danger&quot; value=&quot;80&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;progress class=&quot;progress is-info&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 标签页 Pictures Music Videos Documents Pixabay 是全球知名的图库网站及充满活力的创意社区,拥有上百万张免费正版高清照片素材,涵盖风景、人物、动态、静物等多种分类,你可以在任何地方使用 Pixabay 图库中的素材…网易云音乐 是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。哔哩哔哩 是国内知名的视频弹幕网站,这里有最及时的动漫新番,最棒的ACG氛围,最有创意的Up主。大家可以在这里找到许多欢乐。石墨文档 是全新一代云 Office 办公软件,支持多人在线协作编辑文档和表格,独有内容级安全,全过程留痕可追溯。PC 端和移动端全覆盖,随时随地远程办公。即写即存… .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); } 点击展开代码 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class=&quot;tabs is-toggle&quot;&gt;&lt;ul&gt;&lt;li class=&quot;is-active&quot;&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-image&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Pictures&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-music&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Music&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-film&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Videos&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;onTabClick(event)&quot;&gt;&lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;far fa-file-alt&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Documents&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;{% raw %}&lt;div id=&quot;Pictures&quot; class=&quot;tab-content&quot; style=&quot;display: block;&quot;&gt;{% endraw %}[Pixabay](https://pixabay.com/zh/) 是全球知名的图库网站及充满活力的创意社区,拥有上百万张免费正版高清照片素材,涵盖风景、人物、动态、静物等多种分类,你可以在任何地方使用 Pixabay 图库中的素材...{% raw %}&lt;/div&gt;{% endraw %}{% raw %}&lt;div id=&quot;Music&quot; class=&quot;tab-content&quot;&gt;{% endraw %}[网易云音乐](https://music.163.com/) 是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。{% raw %}&lt;/div&gt;{% endraw %}{% raw %}&lt;div id=&quot;Videos&quot; class=&quot;tab-content&quot;&gt;{% endraw %}[哔哩哔哩](https://www.bilibili.com/) 是国内知名的视频弹幕网站,这里有最及时的动漫新番,最棒的ACG氛围,最有创意的Up主。大家可以在这里找到许多欢乐。{% raw %}&lt;/div&gt;{% endraw %}{% raw %}&lt;div id=&quot;Documents&quot; class=&quot;tab-content&quot;&gt;{% endraw %}[石墨文档](https://shimo.im/) 是全新一代云 Office 办公软件,支持多人在线协作编辑文档和表格,独有内容级安全,全过程留痕可追溯。PC 端和移动端全覆盖,随时随地远程办公。即写即存...{% raw %}&lt;/div&gt;{% endraw %}&lt;style type=&quot;text/css&quot;&gt;.content .tabs ul { margin: 0; }.tab-content { display: none; }&lt;/style&gt;&lt;script&gt;function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active');}&lt;/script&gt; 彩色突出 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;div class=&quot;notification is-info&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;div class=&quot;notification is-success&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;div class=&quot;notification is-warning&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;div class=&quot;notification is-danger&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;article class=&quot;message is-info&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;article class=&quot;message is-success&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;article class=&quot;message is-warning&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded123{% raw %}&lt;article class=&quot;message is-danger&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} 活用 Bulma 美化 Icarus 文章Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 >folded12345{% raw %}&lt;article class=&quot;message is-info&quot;&gt;&lt;div class=&quot;message-header&quot;&gt;{% endraw %}活用 Bulma 美化 Icarus 文章{% raw %}&lt;/div&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。{% raw %}&lt;/div&gt;&lt;/article&gt;{% endraw %} 隐藏代码块点击展开代码 >folded123// ``` js 点击展开代码 &gt;folded// console.log('I love Icarus!');// ``` 你知道的太多了 .heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } iMaeGoo 出自独立游戏 World of Goo 里小粘球的叫声，读作 /ɪ’mæɡu/ 不是爱妹狗啊，在家里电脑还是个大头（CRT）的时候就在玩了，其实头像也是在当时设定的，一直沿用至今。找不到女朋友誓不改头像 点击展开代码 >folded1234567{% raw %}&lt;style type=&quot;text/css&quot;&gt;.heimu { color: #000; background-color: #000; }.heimu:hover { color: #fff; }&lt;/style&gt;{% endraw %}**iMaeGoo** 出自独立游戏 [World of Goo](https://store.steampowered.com/app/22000/) 里小粘球的叫声，读作 /ɪ'mæɡu/ {% raw %}&lt;span class=&quot;heimu&quot;&gt;不是爱妹狗啊&lt;/span&gt;{% endraw %}，在家里电脑还是个大头（CRT）的时候就在玩了，其实头像也是在当时设定的，一直沿用至今。{% raw %}&lt;span class=&quot;heimu&quot;&gt;找不到女朋友誓不改头像&lt;/span&gt;{% endraw %} 让简介不出现在正文我们知道 Hexo 用 可以分隔简介和正文部分，但这样简介也会在正文中出现，如果我们不想让简介部分出现在正文呢？ 点击展开代码 >folded123456789101112131415这里的内容会出现在 **简介和正文**{% raw %}&lt;div class=&quot;post-summary&quot;&gt;{% endraw %}这里的内容只会出现在 **简介**{% raw %}&lt;/div&gt;{% endraw %}&lt;!-- more --&gt;&lt;style type=&quot;text/css&quot;&gt;.post-summary { display: none; }&lt;/style&gt;这里的内容只会出现在 **正文** 封面图来源声明&nbsp;&nbsp;Vector Landscape Vectors by Vecteezy 点击展开代码 >folded1234&lt;a class=&quot;tag is-dark is-medium&quot; href=&quot;https://www.vecteezy.com/free-vector/vector-landscape&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;icon&quot;&gt;&lt;i class=&quot;fas fa-camera&quot;&gt;&lt;/i&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;Vector Landscape Vectors by Vecteezy&lt;/a&gt; 展开/折叠点击显/隐内容 想要折叠的东西 点击展开代码 >folded123{% fold 点击显/隐内容 %}想要折叠的东西{% endfold %}","link":"/2022/12/03/%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"二叉搜索树 BST","text":"BST（Binary Search Tree）具有以下性质： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值。 若右子树不空，则右子树上所有结点的值均大于它的根结点的值。 左、右子树也分别为二叉排序树。 没有权值相等的结点。 节点BST中的每一个节点包含以下信息： 当前节点的权值，也就是序列里的数。 左右子树的下标，如果没有则为0。 该节点权值出现的次数。 该节点子树和自己的节点数量之和。 123struct tree{ int left, right, val, size, cnt;}T[10010]; 插入从根节点开始，比较节点的权值和想要插入的值，如果节点的权值等于想要插入的值，节点权值出现次数加一，如果想要插入的值比节点的权值小，就说明应该往节点的左边搜索，反之亦然。如果没有对应的子节点，则该子节点就是正确的位置。 123456789101112131415161718192021222324252627void add(int x, int v){ T[x].size++; if(T[x].val==v){ T[x].cnt++; return; } if(v&lt;T[x].val){ if(T[x].left!=0) add(T[x].left, v); else{ T[x].left=++sum; T[sum].cnt=1; T[sum].size=1; T[sum].val=v; } }else{ if(T[x].right!=0) add(T[x].right, v); else{ T[x].right=++sum; T[sum].cnt=1; T[sum].size=1; T[sum].val=v; } }} tip：根节点必须手动初始化 前驱&amp;后继某个数$x$的前驱定义为小于$x$，且最大的数。某个数$x$的后继定义为大于$x$，且最小的数。 前驱从根节点开始 比较节点权值和要找前驱的数。 如果节点权值比要找前驱的数大，说明这个节点和它的右子树都没有要找的前驱，只能往它的左子树查。如果没有左子树，就返回已经找到的值，因为已经无法再搜索下去了。 如果节点权值比要找前驱的数小，说明这个节点的权值可能是要找的前驱，但是无法确定它的右子树里面还有比它更大的数，所以要继续搜索右子树。如果这个节点权值数量不为0，就更新答案。如果已经没有右子树了，说明已经没有更合适的答案了，直接返回当前节点的权值。 12345678910111213141516int querypre(int x, int val, int ans){ if(T[x].val&gt;=val){ if(T[x].left==0) return ans; else querypre(T[x].left, val, ans); }else{ if(T[x].right==0) return T[x].val&lt;val ? T[x].val : ans; //可以直接返回T[x].val if(T[x].cnt==0) return querypre(T[x].right, val, ans); else return querypre(T[x].right, val, T[x].val); }} 后继和找前驱完全相反，这里就不多赘述。 12345678910111213141516int querynext(int x, int val, int ans){ if(T[x].val&lt;=val){ if(T[x].right==0) return ans; else querynext(T[x].right, val, ans); }else{ if(T[x].left==0) return T[x].val&gt;val ? T[x].val : ans;//可以直接返回T[x].val if(T[x].cnt==0) return querynext(T[x].left, val, ans); else return querynext(T[x].left, val, T[x].val); }} 按值找排名1234567int queryRankFromVal(int x, int val){ if(x==0) return 0; if(T[x].val==val) return T[T[x].left].size+1; else if(T[x].val&gt;val) return queryrankfromval(T[x].left, val); else return queryrankfromval(T[x].right, val)+T[x].cnt+T[T[x].left].size;} 按排名找值12345678int queryValFromRank(int x, int rank){ if(T[T[x].left].size&gt;=rank) return queryvalfromrank(T[x].left, rank); else if(T[T[x].left].size+T[x].cnt&gt;=rank) return T[x].val; else return queryvalfromrank(T[x].right, rank-T[T[x].left].size-T[x].cnt);} 参考和模板题参考https://www.cnblogs.com/do-while-true/p/12382796.html 模板题P5076 【深基16.例7】普通二叉树（简化版）","link":"/2020/07/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/"},{"title":"代数结构","text":"代数结构(algebraische Strukturen)半群(Halbgruppe)一个半群是一种代数结构$\\left\\langle A, \\bullet^{2}\\right\\rangle$, 其具有如下的性质: 满足结合律, 也就是说$\\forall a, b, c:(a \\cdot(b \\bullet c))=((a \\cdot b) \\cdot c)$ &nbsp; 一个可换的的半群还需满足如下性质: 满足交换律, 也就是说$\\forall a, b:(a \\cdot b)=(b \\bullet a)$ &nbsp; 幺半群(Monoid)一个(可换的)幺半群是一种代数结构$\\left\\langle A, \\bullet^{2}, 1^{0}\\right\\rangle$, 其具有如下性质: $\\left\\langle A, \\bullet^{2}\\right\\rangle$是一个(可换的)半群 存在单位元(neutrales Element): $1^{0} ($关于$\\bullet)$ 在半群的基础上新加了**单位元$1^{0}$的需求** &nbsp; 群(Gruppe)一个(可换的)群是一种代数结构$\\left\\langle A, \\bullet^{2}, 1^{0}\\right\\rangle$, 其具有以下性质: $\\left\\langle A, \\bullet^{2}, 1^{0}\\right\\rangle$是一个(可换的)幺半群 存在逆元(关于$\\bullet$), 也就是说$\\forall a \\exists b:(a \\cdot b)=1=(b \\cdot a)$ 在幺半群的基础上新加了**元素的逆元存在需求** &nbsp; 一个可换的群也被称作阿贝尔群(abelsche Gruppe) &nbsp; 环(Ring)一个(伪)环是一个代数结构$\\left\\langle A,+^{2}, \\bullet^{2}, 0^{0}\\right\\rangle$ (或者$\\left\\langle A,+^{2}, \\bullet^{2}, 0^{0}, 1^{0}\\right\\rangle$), 其具有以下性质: $\\left\\langle A, \\bullet^{2}\\right\\rangle$是一个半群(或者$\\left\\langle A, \\bullet^{2}, 1^{0}\\right\\rangle$是一个幺半群) $\\left\\langle A,+^{2}, 0^{0}\\right\\rangle$是一个可换的群 从两个方向满足交换律, 也就是说$\\forall a, b, c:(a \\cdot(b+c))=(a \\bullet b+a \\cdot c)$并且$((a+b) \\cdot c)=((a \\cdot c)+(b \\cdot c))$ 在群的基础上新增了对于**交换律的需求** &nbsp; 域(Körper)一个域是一个代数结构$\\left\\langle A,+^{2}, \\bullet^{2}, 0^{0}, 1^{0}\\right\\rangle$, 其具有以下性质: $\\left\\langle A,+^{2}, \\bullet^{2}, 0^{0}, 1^{0}\\right\\rangle$是一个伪环 $\\left\\langle A \\backslash{0}, \\bullet^{2}, 1^{0}\\right\\rangle$是一个可换的群 以上所有性质都有, 并且新增了对于**非0单位有逆元的需求**","link":"/2021/07/11/%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84/"},{"title":"拓扑排序","text":"把一个图的所有节点排序，使得每一条有向边$(u, v)$对应的$u$都排在$v$的前面。在图论中，这个问题称为拓扑排序(topological sort)。 不难发现：如果图中存在有向环，则不存在拓扑排序，反之则存在。所以可以用拓扑排序来检验是否存在有向环。 BFS首先要找出所有的起点，也就是所有入度为0的点。入度为0的点在DAG中是一定存在的。（证明在这篇博客中可以找到） 若是队列不空，取出队列头$x$，遍历所有起点是$x$的边。 每次遍历中，更新数据，并删除这条边，代码实现就是这条边的终点$y$的入度减一。 如果$y$的入度被减为0，则说明$y$的所有前驱都被计算过了，$y$成了新的起点，将$y$插入队列。 如此循环直至队列空。 最后统计数据。 如果要判定有向环，要加一个vis[]， 确保每个点只访问一次。 1234567891011121314151617181920//这里我用邻接表储存边//把一条边的信息封装到edge结构体内for(int i=1;i&lt;=n;i++){ if(inDeg[i]==0) Q.push(i);}while(!Q.empty()){ int f=Q.front(); for(int i=0;i&lt;G[f].size();i++){ edge e=G[f][i]; inDeg[e.to]--; //更新数据 if(inDeg[e.to]==0){ Q.push(e.to); } } Q.pop();} DFS《算法竞赛入门经典》里还给出了一种DFS的拓扑排序，这里只是输出一张图的拓扑排序。 12345678910111213141516171819int c[maxn];int topo[maxn], t;bool dfs(int u){ c[u]=-1; //访问标志 for(int v=0;v&lt;n;v++) if(G[u][v]){ if(c[v]&lt;0) return false; //存在有向环，失败退出 else if(!c[v] &amp;&amp; !dfs[v]) return false; } c[u]=1;topo[--t]=u; return true;}bool toposort(){ t=n; memset(c, 0, sizeof(c)); for(int u=0;u&lt;n;u++) if(!c[u]) if(!dfs[u]) return false; return true;} 这里用到了一个 c 数组，c[u]=0 表示从来没有访问过（从来没有调用过dfs(u)）；c[u]=1 表示已经访问过，并且还递归访问过它所有的子孙（即dfs(u)曾被调用过，并已经返回）；c[u]=-1 表示正在访问（即递归调用dfs(u)正在栈帧中，尚未返回）。 参考https://www.luogu.com.cn/blog/106510/topo-sort 《算法竞赛入门经典》","link":"/2020/07/07/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"子序列问题","text":"最长上升子序列（LIS，Longest Increasing Subsequence） “给定n个整数 A1， A2，… ，An，按从左到右的顺序选出尽量多的整数，组成一个上升子序列（子序列可以理解为：删除0个或多个数，其他数的顺序不变）。例如序列1，6，2，3，7，5，可以选出上升子序列1，2，3，5，也可以选出1，6，7，但前者更长。选出的上升子序列相邻元素不能相等”——《算法竞赛入门经典》 （部分解法灵感来源于洛谷题解） 解法（动态规划）状态转移方程d(i)=max\\{0, d(j)|j","link":"/2020/07/03/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"},{"title":"欧拉筛法（线性筛素数）","text":"欧拉筛法，一种可以在线性的时间复杂度内筛出素数的算法。 算法思路对于每一个数（无论质数合数）x，筛掉所有小于x最小质因子的质数乘以x的数。比如对于77,它分解质因数是7*11，那么筛掉所有小于7的质数*77，筛掉2*77、3*77、5*77。 代码12345678910111213141516171819//vis[] 记录一个数是否被访问过的数组//cnt0 素数计数器//prime[] 最后所有筛出来的素数都会进到这个数组里面//MAXN 上限//准备工作vis[0]=1;vis[1]=1;cnt0=0;for(int i=2;i&lt;=MAXN;i++){ if(!vis[i]) prime[++cnt0]=i; //若是这个数还没被访问过，则说明是素数，加入prime[] for(int j=1;j&lt;=cnt0;j++){ //从已经筛出来的素数里面开始筛选，保证从小到大 if(i*prime[j]&gt;MAXN) break; //越过上限，而且后面的数必比他大，跳出循环 vis[i*prime[j]]=1; //筛掉所有小于i最小质因子的质数乘以i的数 if(i % prime[j] == 0) break; //到达最小质因数，后面的数必比他大，跳出循环 }} 参考&amp;证明https://www.cnblogs.com/jason2003/p/9761296.html","link":"/2020/08/01/%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%88%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%EF%BC%89/"},{"title":"算法模板","text":"常用算法的模板 数论快速幂1234567891011ll fastPower(ll base, ll power, ll mod) { ll result = 1; while (power &gt; 0) { if (power &amp; 1) { result = result * base % mod; } power &gt;&gt;= 1; base = (base * base) % mod; } return result;} GCD直接用STL库里的__gcd()就好了 1__gcd() EXGCD1234567891011// 解ax + by = gcd(a, b)的x和y// 求最小非负整数解的话外面加一句// x = (x % b + b) % b;void exgcd(ll a_, ll b_, ll &amp;d_, ll &amp;x_, ll &amp;y_) { if (!b_) { d_ = a_, x_ = 1, y_ = 0; } else { exgcd(b_, a_ % b_, d_, y_, x_); y_ -= x_ * (a_ / b_); }} 通过EXGCD求逆元123456// 返回 a_^(-1) mod n_ll invMul(ll a_, ll n_) { ll d_, x_, y_; exgcd(a_, n_, d_, x_, y_); return d_ == 1 ? (x_ + n_) % n_ : -1;} 通过递推的方式求逆元123456789101112131415161718192021222324252627282930313233343536373839404142434445ll fastPower(ll base, ll power, ll mod) { ll result = 1; while (power &gt; 0) { if (power &amp; 1) { result = result * base % mod; } power &gt;&gt;= 1; base = (base * base) % mod; } return result;}const int MOD=7; //替换成对应的MOD值//阶乘和逆元ll fac[200010]; //阶乘ll inv[200010]; //逆元 void getfac(){ fac[0] = inv[0] = 1; for (int i = 1 ; i &lt;= 200000 ; i++) { fac[i] = fac[i-1] * i % MOD; inv[i] = fastPower(fac[i], MOD-2, MOD); //表示i的阶乘的逆元 }}//组合数inline ll getC(ll n,ll m)//C(n,m) = n!/((n-m)!*m!) % MOD{ return fac[n] * inv[n-m] % MOD * inv[m] % MOD;}//当 n，m 过大时，可以用Lucas定理降数据inline ll Lucas(ll n,ll m){ if(n &lt; MOD &amp;&amp; m &lt; MOD) return getC(n, m); return Lucas(n/MOD, m/MOD) * getC(n%MOD, m%MOD)%MOD;}//排列数inline ll getA(ll n,ll m) //A(n,m) = n!/(n-m)! % MOD{ return n * inv[n-m] % MOD;} 中国剩余定理1234567891011ll CRT(ll n_, vector&lt; ll &gt; &amp;a_, vector&lt; ll &gt; &amp;m_) { ll M_ = 1, d_, y_, x_ = 0; for (int i = 1; i &lt;= n_; i++) M_ *= m_[i]; for (int i = 1; i &lt;= n_; i++) { ll w = M_ / m_[i]; exgcd(m_[i], w, d_, d_, y_); x_ = (x_ + y_ * w * a_[i]) % M_; } return (x_ + M_) % M_;} BSGS12345678910111213141516171819202122232425// y^x 同余 z (mod p)的最小非负整数解xll bsgs(ll y, ll z, ll p) { map&lt; ll, ll &gt; M; ll m = sqrt(p) + 1; y %= p; z %= p; ll cnt = 0, sum = 1; for (int d = gcd(y, p); d != 1; d = gcd(y, p)) { if (z % d) return -LLONG_MAX; ++cnt, z /= d, p /= d, sum = sum * y / d % p; if (z == sum) return cnt; } for (ll i = 0, zy_i = z; i &lt;= m; i++, zy_i = zy_i * y % p) M[zy_i] = i; for (ll i = 1, y_m = fastPower(y, m, p), y_mi = y_m; i &lt;= m; i++, y_mi = y_mi * y_m % p) if (M.count(y_mi)) return i * m - M[y_mi]; return -LLONG_MAX;} 分解质因数/线性筛123456789101112131415161718192021222324252627282930struct Prime { int n; vector&lt;int&gt; prime, nxt; vector&lt;bool&gt; isp; Prime(int n) : n(n+1), prime(1), nxt(n+1), isp(n+1,1) { calc(); } void calc() { isp[1] = 0; for (int i = 2;i &lt;= n; ++i) { if (isp[i]) prime.push_back(i), nxt[i] = i; for (int j = 1;j &lt; sz(prime) &amp;&amp; i*prime[j] &lt;= n; ++j) { isp[i*prime[j]] = 0; nxt[i*prime[j]] = prime[j]; if (i % prime[j] == 0) break; } } } vector&lt;pair&lt;ll,int&gt;&gt; factorize(ll x) { vector&lt;pair&lt;ll,int&gt;&gt; ret; while (x != 1) { int p = nxt[x]; if (ret.empty() || ret.back().first != p) ret.push_back({p, 1}); else ret.back().second++; x /= p; } return ret; }}; 单个质因数分解123456789vector&lt;pair&lt;ll, ll&gt;&gt; factorize(ll x) {//唯一分解定理 vector&lt;pair&lt;ll, ll&gt;&gt; ret; for (int i = 2; (ll)i*i &lt;= x; ++i) if (x % i == 0) { ret.push_back({i, 0}); while (x % i == 0) x /= i, ret.back().second++; } if (x &gt; 1) ret.push_back({x, 1}); return ret;}","link":"/2022/01/07/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"},{"title":"链式前向星存图","text":"一种数据结构，以储存边的方式来存储图。构造方法如下：读入每条边的信息，根据边的起点将边存入对应链表中。通过和链表一样的遍历可以查出以某个点出发的边。除了不能直接用起点终点定位以外，前向星几乎是完美的。 边每条边需要包含一下信息 这条边的起点 这条边的重点 下一条同样起点的边的地址 权值（可选） 123struct edge{ int from, to, next;}E[1000010]; 示例假设我们要存一张这样的图： 那它在内存中应该是这么存储的： 图的构建依次插入所有的边。 每次插入边时，总是更改链表头部。 123456void addEdge(int from, int to){ E[++cnt].from=from; E[cnt].to=to; E[cnt].next=head[from]; head[from]=cnt;} 图的遍历可以通过DFS或BFS。 这里只给出怎么从前向星里获得以某个点为起点的所有边，具体如何用DFS或BFS根据实际情况。 123456int temp=head[x]; //x是图中某个点while(temp!=0){ //dfs到E[temp].to //bfs到E[temp].to temp=E[temp].next;}","link":"/2020/07/06/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE/"},{"title":"Educational Codeforces Round 157 记录","text":"[X] A [X] B [X] C [X] D [X] E [ ] F [ ] G A. Treasure Chest题意你在一个OX正半轴的原点, 有一个宝箱在x, 钥匙在y, 你可以做如下操作: 向左或者向右走一格(耗时1s) 捡起钥匙或者宝箱(不耗时) 放下宝箱(不耗时) 打开宝箱(如果有钥匙) 此外还有一个限制: 你最多捡起箱子k秒, 体力就会耗尽 问打开宝箱的最小耗时. 思路如果去宝箱的路上就能经过钥匙, 那么直接走过去开为最优解. 如果宝箱离的比钥匙近, 那么扛着宝箱往钥匙走, 直到不能走为止(体力耗尽或者已经走到钥匙处), 此时去捡钥匙回来开宝箱. 代码123456789101112int x, y, k;void Main(int kase){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; if(y&lt;=x){ cout&lt;&lt;x&lt;&lt;endl; }else{ int r=min(y, x+k); cout&lt;&lt;r+2*(y-r)&lt;&lt;endl; }} 吐槽赛时忘记取min, wa了一发… B. Points and Minimum Distance题意给你2n个整数, 将这2n个整数分入n个对, 每一个整数对是2D平面上的一个坐标, 你可以从任意一个点开始, 再从任意一个点结束, 但是要求是经过所有的点. 问路程最小的配对方案. ps. 路程的计算采用绝对距离($|x_1-x_2|+|y_1-y_2|$) 思路赛时的时候其实我是观察样例, 发现总是最大的和最小的配, 如此循环. 可以证明这是路程最小的方案. 代码12345678910111213141516171819int n;void Main(int kase){ cin&gt;&gt;n; vector&lt;int&gt; A(2*n+5); for(int i=1;i&lt;=2*n;i++) cin&gt;&gt;A[i]; sort(A.begin()+1, A.begin()+1+2*n); int ans=0; for(int i=2;i&lt;=n;i++){ ans+=abs(A[i]-A[i-1]); ans+=abs(A[2*n-i+1]-A[2*n-i+2]); } cout&lt;&lt;ans&lt;&lt;endl; for(int i=1;i&lt;=n;i++){ cout&lt;&lt;A[i]&lt;&lt;&quot; &quot;&lt;&lt;A[2*n-i+1]&lt;&lt;endl; }} C. Torn Lucky Ticket题意一张票的代码是0~9组成的非空字符串. 一张幸运票是: 长度为偶数 前一半的数位和与后一半相同 给你n张票的碎片, 问有多少对碎片可以组成一张幸运票. 思路赛时没过. 后来看题解觉得问题是在统计的时候有重复的, 比标答大的输出也证明了这一点. 规定: 只有长的票才能和短的票配对. 因为碎片的长度最大是5, 所以可以暴力写出所有的可能: 长度为1: 配长度为1 长度为2: 配长度为2 长度为3: 配长度为3或1 长度为4: 配长度为4或2 长度为5: 配长度为5或3或1 顺序的问题需要注意一下. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int n;pair&lt;int, int&gt; process(int x){ int cnt=0, sum=0; while(x){ cnt++; sum+=x%10; x/=10; } return make_pair(cnt, sum);}int get_digit(int x, int index){ for(int i=1;i&lt;index;i++) x/=10; return x%10;}void Main(ll kase){ cin&gt;&gt;n; vector&lt;int&gt; A(n+5); for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i]; sort(A.begin()+1, A.begin()+n+1); vector&lt;map&lt;int, int&gt;&gt; rec(10); ll ans=0; for(int i=1;i&lt;=n;i++){ auto [digits, sums]=process(A[i]); switch(digits){ case 1: ans+=rec[1][sums]*2; break; case 2: ans+=rec[2][sums]*2; break; case 3: ans+=rec[3][sums]*2; ans+=rec[1][sums-get_digit(A[i], 1)*2]; ans+=rec[1][sums-get_digit(A[i], 3)*2]; break; case 4: ans+=rec[4][sums]*2; ans+=rec[2][sums-get_digit(A[i], 1)*2]; ans+=rec[2][sums-get_digit(A[i], 4)*2]; break; case 5: ans+=rec[5][sums]*2; ans+=rec[3][sums-get_digit(A[i], 1)*2]; ans+=rec[3][sums-get_digit(A[i], 5)*2]; ans+=rec[1][sums-get_digit(A[i], 1)*2-get_digit(A[i], 2)*2]; ans+=rec[1][sums-get_digit(A[i], 4)*2-get_digit(A[i], 5)*2]; break; } rec[digits][sums]++; ans++; } cout&lt;&lt;ans&lt;&lt;endl;} D. XOR Construction题意给你$n-1$个数: $a1, a_2, … , a{n-1}$ 构造$b1, b_2, … , b{n-1}$满足： b是一个从0到n-1的排列 $bi \\oplus b{i+1} = a_i $ 思路可以推出：$bi = b_1 \\oplus a_1 \\oplus … \\oplus a{i-1}$ （这个我赛时推得是反的流汗） 所以所有的$b_i$都和$b_1$有关。我们只需要确定$b_1$的取值就行了。 我们可以先处理$ci = \\oplus{j=1}^{i-1} a_j$ 然后式子就成了：$b_i = b_1 \\oplus c_i$ 此题无解的条件是：$c_i$存在相同项，然而此题保证有解，所以我们只需要保证最大值小于n即可。 建一个trie存$c_i$，然后对每个$b_1$的取值，查最大的异或值。 代码12345678910111213141516171819202122232425262728293031323334353637vector&lt;array&lt;int, 2&gt;&gt; trie(2);void insert(int x){ int cur=1; for(int i=30;i&gt;=0;i--){ if(!trie[cur][(x&gt;&gt;i)&amp;1]) trie[cur][(x&gt;&gt;i)&amp;1]=trie.size(), trie.emplace_back(); cur=trie[cur][(x&gt;&gt;i)&amp;1]; }}int query(int x){ int cur=1, ret=0; for(int i=30;i&gt;=0;i--){ int k=(x&gt;&gt;i)&amp;1; if(trie[cur][k^1]) cur=trie[cur][k^1], ret+=(1&lt;&lt;i); else cur=trie[cur][k]; } return ret;}int n, ans;void Main(int kase){ cin&gt;&gt;n; vector&lt;int&gt; A(n+5), C(n+5); for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i], C[i]=C[i-1]^A[i], insert(C[i]); for(int i=0;i&lt;n;i++) if(query(i)&lt;n) { ans=i; break; } cout&lt;&lt;ans&lt;&lt;&quot; &quot;; for(int i=1;i&lt;n;i++){ cout&lt;&lt;(ans^C[i])&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;} E. Infinite Card Game题意有点像炉石，一张卡有一个攻击力，一个血条。A和B有n和m张卡牌。 A先出牌，随后B必须出一张能够秒杀A出的这张卡的卡牌，随后A也必须出一张能够秒杀场上这张卡的一张卡牌，以此类推。一张卡牌被秒了之后，直接回到出牌者的手牌里。 如果某一个时刻有人没卡能出的，那么对手获胜。 问A第一张能出的所有牌里面，A赢，A输或者打平的牌数。 思路这题乍一看没啥思路。 其实对于一张卡，对手的手牌里总有一张最优解牌：攻击力大于这张牌并且血最厚的那张。这是一个谈心，在所有能秒杀这张牌的手牌中，血越厚对手能选的牌就越少。 我们可以预处理所有牌的最优解牌。 然后其实这就构成了一个有向图，每条边从一张牌连向他的最优解牌。我们就可以做拓扑排序了。 随后就是一个反向更新的过程，所有拓扑排序没有扫过的牌都是在一个环上的，如果到了一个环上就必定平局。 如果最后A出不了牌，B获胜，反之A获胜。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102using card=pair&lt;int, int&gt;;using graph=vector&lt;vector&lt;int&gt;&gt;;// A 已经出了一张牌i// B 需要一张牌j解void calcDefence(int sza, vector&lt;card&gt; &amp;A, int szb, vector&lt;card&gt; &amp;B, vector&lt;int&gt; &amp;ret){ vector&lt;int&gt; sufmax(szb+5); int curmax=0, curi; for(int i=szb;i&gt;=1;i--){ if(B[i].second&gt;curmax){ curmax=B[i].second; curi=i; } sufmax[i]=curi; } for(int i=1;i&lt;=sza;i++){ int l=1, r=szb, c=INT_MAX; while(l&lt;=r){ int m=(l+r)/2; if(B[m].first&gt;A[i].second){ c=min(c, m); r=m-1; }else l=m+1; } if(c==INT_MAX) ret[i]=0; else ret[i]=sufmax[c]; }}int n, m;void Main(int kase){ cin&gt;&gt;n; vector&lt;card&gt; A(n+5); for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i].first; for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i].second; cin&gt;&gt;m; vector&lt;card&gt; B(m+5); for(int i=1;i&lt;=m;i++) cin&gt;&gt;B[i].first; for(int i=1;i&lt;=m;i++) cin&gt;&gt;B[i].second; sort(A.begin()+1, A.begin()+n+1, [](card a, card b){ return a.first&lt;b.first; }); sort(B.begin()+1, B.begin()+m+1, [](card a, card b){ return a.first&lt;b.first; }); vector&lt;int&gt; retA(n+5), retB(m+5); calcDefence(n, A, m, B, retA); calcDefence(m, B, n, A, retB); graph G(n+m+5); vector&lt;int&gt; ind(n+m+5); for(int i=1;i&lt;=n;i++) if(retA[i]) G[i].push_back(n+retA[i]), ind[n+retA[i]]++; for(int i=1;i&lt;=m;i++) if(retB[i]) G[n+i].push_back(retB[i]), ind[retB[i]]++; queue&lt;int&gt; Q; for(int i=1;i&lt;=n+m;i++) if(ind[i]==0) Q.push(i); vector&lt;int&gt; topo; while(!Q.empty()){ auto u=Q.front(); Q.pop(); topo.push_back(u); for(auto v : G[u]){ if(!--ind[v]) Q.push(v); } } vector&lt;int&gt; f(n+m+5); for(int i=topo.size()-1;i&gt;=0;i--){ int u=topo[i]; if(G[u].size()==0) { if(u&gt;n) f[u]=2; else f[u]=1; }else{ for(auto v : G[u]){ f[u]=f[v]; } } } int ans1=0, ans2=0, ans3=0; for(int i=1;i&lt;=n;i++){ if(f[i]==1) ans1++; if(f[i]==2) ans3++; if(f[i]==0) ans2++; } cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;&quot; &quot;&lt;&lt;ans3&lt;&lt;endl;}","link":"/2023/11/04/Educational-Codeforces-Round-157-%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"games","slug":"games","link":"/tags/games/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"Codeforces 1800","slug":"Codeforces-1800","link":"/tags/Codeforces-1800/"},{"name":"interactive","slug":"interactive","link":"/tags/interactive/"},{"name":"probabilities","slug":"probabilities","link":"/tags/probabilities/"},{"name":"bitmasks","slug":"bitmasks","link":"/tags/bitmasks/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"number theory","slug":"number-theory","link":"/tags/number-theory/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"brute force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"constructive algorithms","slug":"constructive-algorithms","link":"/tags/constructive-algorithms/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"赛后总结 &amp; 补题","slug":"赛后总结-补题","link":"/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93-%E8%A1%A5%E9%A2%98/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"VirtualBox","slug":"VirtualBox","link":"/tags/VirtualBox/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"TUM","slug":"TUM","link":"/tags/TUM/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Java学习笔记","slug":"Java学习笔记","link":"/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Hexo搭建","slug":"Hexo搭建","link":"/categories/Hexo%E6%90%AD%E5%BB%BA/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"课堂笔记","slug":"课堂笔记","link":"/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}],"pages":[{"title":"Bsc Project","text":"Bsc. Project的Document .post-summary { display: none; } data_compress L3inflate.hpp line 650 -&gt; inlinehuffman_decoder all non-inline function -&gt; inline function 规范化了kernel的命名 Snappy先把文件分成若干个chunk(由于host buffer大小的限制), 每个chunk再分成若干个block, kernel可以一次性处理一个chunk, 但是内部还是一个block一个block压缩的 Questions:gzip&amp;zlib的文件名和文件大小不太对劲 gzip/zlib和snappy完工 lz4 host buffer size和block size目前是定死的，日后可以更改 zstd所有的步骤都在kernel里面 -&gt; 64GB要开一个64GB的vector可能开不下 -&gt; 可能需要overlap 所有的decompress 加个max_out_size 优化Application(多个xclbin，因为一个xclbin只能装40个kernel)完成其他的压缩方式(lz4 zstd)，但是有的不支持大文件压缩，需要优化 关于gzip的大文件mm压缩，代码写了半小时，nnd花了10个小时找bug，最后发现是num_core设小了，是4，换成默认的8就好了。。。tmd不是这个问题，是sw_emu有bug，我麻了。以后不用sw_emu了。。。 gzip/zlib compressMM现在支持大文件了，但是checksum还是有点问题。。。 gzip/zlib的decompress分段式stream居然一次性就过了！稍微修改了一下S2MM的内容，不会多输出东西。原版是让他多输出东西然后 snappy的CRC也是0gzip不同的chunksize和blocksize压出来的crc也不同，这个crc再解压的时候是不检查的 // 更改了snappy decompress kernel的inputSize成uint64_t，正确性需要以后测试 所有的compress checksum都暂时忽略掉lz4 dict ID假设是没设置的，设置了就报错lz4的footer取消了checksum，因为64GB不好设置这个 zstd的压缩方法：将文件分块，每块送进kernel压缩，会产出多个frame，最后将这些frame按顺序放好即可 zstd的解压方法：zstd的kernel一次能处理一个frame，所以按frame依次将数据传入，最后将解压好的数据按顺序放好即可 lz4的压缩方法：将文件分块，每块送进kernel压缩，会产生多个block，每个block选择压缩的还是未压缩的，将选择好的数据按顺序放回即可所有的block组成一个frame（其实可以有多个frame） lz4的解压缩方法：lz4的解压缩kernel能处理多个block，所以对于每个frame，将block分段读入解压，将解压好的数据按顺序放好 Snappy decompress kernel MM有缺陷，已经帮他修复好了Snappy在compress的时候要用一个crc32-c的值，目前是0，需要修复：https://github.com/google/crc32c 多个kernel需要实现（data_compression和security）。 database: Join:CH_NM = channel_num: 4 -&gt; 1HASHWH: 3 -&gt; 0 ==&gt; PU = 1 &lt;&lt; HASHWH: 8 -&gt; 1 Part:CH_NM = channel_num: 4 -&gt; 1HASHWH: 3 -&gt; 0 ==&gt; PU = 1 &lt;&lt; HASHWH: 8 -&gt; 1 Aggr:CH_NM = channel_num: 4 -&gt; 1 security:lz_compress.hpp: lzCompress() uram -&gt; lutram TODO:完善gzip/zlib和snappy接口gzip外部的接口里面有hexdump，后期需要去除有的不支持大文件压缩，需要优化优化Pointer(集成内置的OCL_CHECK)test多block下压缩算法（gzip/zlib）是否能顺利运行加个时间的记录hash function","link":"/old_posts/Bsc-Project.html"}]}